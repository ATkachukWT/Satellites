import{a as F,b as g}from"./chunk-65A5HIL4.js";import{a as U}from"./chunk-KAFWB3JH.js";import{e as y}from"./chunk-W26XKMAT.js";import{a as M}from"./chunk-NQWYPF77.js";import{h as L,t as D}from"./chunk-TPFJWNIU.js";import{y as h}from"./chunk-HP4LYRR4.js";import{m as I}from"./chunk-LFH24RLM.js";import{a as E}from"./chunk-4XZ6X7MQ.js";import{C as v,m as N}from"./chunk-KGVXGH6H.js";import{E as d,r as G}from"./chunk-ETE32IYO.js";import{I as A,J as R,r as C}from"./chunk-ONUGDWDK.js";import{d as k,e as T}from"./chunk-QHVIRF5H.js";import{t as c}from"./chunk-UHRSAPGQ.js";import{a as m,b as x}from"./chunk-N2WTMF3X.js";var P="xlink:href",w="2.0.0",j="__esri_wfs_id__",_="wfs-layer:getWFSLayerTypeInfo-error",H="wfs-layer:empty-service",$="wfs-layer:feature-type-not-found",J="wfs-layer:geojson-not-supported",Q="wfs-layer:kvp-encoding-not-supported",K="wfs-layer:malformed-json",W="wfs-layer:unknown-geometry-type",B="wfs-layer:unknown-field-type",Z="wfs-layer:unsupported-spatial-reference",ee="wfs-layer:unsupported-wfs-version";async function Ie(r,t){let e=te((await d(r,{responseType:"text",query:m({SERVICE:"WFS",REQUEST:"GetCapabilities",VERSION:w},t?.customParameters),signal:t?.signal})).data);return ne(r,e),e}function te(r){let t=Y(r);we(t),q(t);let e=t.firstElementChild,a=k(oe(e));return{operations:ae(e),get featureTypes(){return Array.from(a())},readFeatureTypes:a}}var re=["json","application/json","geojson","application/json; subtype=geojson","application/geo+json"];function O(r){for(let t of re){let e=r.findIndex(a=>a.toLowerCase()===t);if(e>=0)return r[e]}return null}function ae(r){let t=!1,e={GetCapabilities:{url:""},DescribeFeatureType:{url:""},GetFeature:{url:"",outputFormat:null,supportsPagination:!1}},a=[],o=[];if(F(r,{OperationsMetadata:{Parameter:n=>{if(n.getAttribute("name")==="outputFormat")return{AllowedValues:{Value:({textContent:i})=>{i&&a.push(i)}}}},Operation:n=>{switch(n.getAttribute("name")){case"GetCapabilities":return{DCP:{HTTP:{Get:i=>{e.GetCapabilities.url=i.getAttribute(P)}}}};case"DescribeFeatureType":return{DCP:{HTTP:{Get:i=>{e.DescribeFeatureType.url=i.getAttribute(P)}}}};case"GetFeature":return{DCP:{HTTP:{Get:i=>{e.GetFeature.url=i.getAttribute(P)}}},Parameter:i=>{if(i.getAttribute("name")==="outputFormat")return{AllowedValues:{Value:({textContent:s})=>{s&&o.push(s)}}}}}}},Constraint:n=>{switch(n.getAttribute("name")){case"KVPEncoding":return{DefaultValue:i=>{t=i.textContent.toLowerCase()==="true"}};case"ImplementsResultPaging":return{DefaultValue:i=>{e.GetFeature.supportsPagination=i.textContent.toLowerCase()==="true"}}}}}}),e.GetFeature.outputFormat=O(o)??O(a),!t)throw new c(Q,"WFS service doesn't support key/value pair (KVP) encoding");if(e.GetFeature.outputFormat==null)throw new c(J,"WFS service doesn't support GeoJSON output format");return e}function ne(r,t){A(r)&&(C(r,t.operations.DescribeFeatureType.url,!0)&&(t.operations.DescribeFeatureType.url=R(t.operations.DescribeFeatureType.url)),C(r,t.operations.GetFeature.url,!0)&&(t.operations.GetFeature.url=R(t.operations.GetFeature.url)))}function V(r){let t=parseInt(r.textContent?.match(/(?<wkid>\d+$)/i)?.groups?.wkid??"",10);if(!Number.isNaN(t))return t}function oe(r){return g(r,{FeatureTypeList:{FeatureType:t=>{let e={typeName:"undefined:undefined",name:"",title:"",description:"",extent:null,namespacePrefix:"",namespaceUri:"",defaultSpatialReference:4326,supportedSpatialReferences:[]},a=new Set;return F(t,{Name:o=>{let{name:n,prefix:i}=S(o.textContent);e.typeName=`${i}:${n}`,e.name=n,e.namespacePrefix=i,e.namespaceUri=o.lookupNamespaceURI(i)},Abstract:o=>{e.description=o.textContent},Title:o=>{e.title=o.textContent},WGS84BoundingBox:o=>{e.extent=I.fromJSON(ie(o))},DefaultCRS:o=>{let n=V(o);n&&(e.defaultSpatialReference=n,a.add(n))},OtherCRS:o=>{let n=V(o);n&&a.add(n)}}),e.title||(e.title=e.name),a.add(4326),e.supportedSpatialReferences.push(...a),e}}})}function ie(r){let t,e,a,o;for(let n of r.children)switch(n.localName){case"LowerCorner":[t,e]=n.textContent.split(" ").map(i=>Number.parseFloat(i));break;case"UpperCorner":[a,o]=n.textContent.split(" ").map(i=>Number.parseFloat(i))}return{xmin:t,ymin:e,xmax:a,ymax:o,spatialReference:v}}function se(r,t,e){return T(r,a=>e?a.name===t&&a.namespaceUri===e:a.typeName===t||a.name===t)}async function Le(r,t,e,a={}){let{featureType:o,extent:n}=await ue(r,t,e,a),{spatialReference:i}=be(r.operations.GetFeature.url,o,a.spatialReference),{fields:s,geometryType:u,swapXY:p,objectIdField:l,geometryField:f}=await pe(r,o,i,a);return{url:r.operations.GetCapabilities.url,name:o.name,namespaceUri:o.namespaceUri,fields:s,geometryField:f,geometryType:u,objectIdField:l,spatialReference:a.spatialReference??new E({wkid:o.defaultSpatialReference}),extent:n,swapXY:p,wfsCapabilities:r,customParameters:a.customParameters}}async function ue(r,t,e,a={}){let o=r.readFeatureTypes(),n=t?se(o,t,e):o.next().value,{spatialReference:i=new E({wkid:n?.defaultSpatialReference})}=a;if(n==null)throw t?new c($,`The type '${t}' could not be found in the service`):new c(H,"The service is empty");let s=n.extent;if(s&&!N(s.spatialReference,i))try{await D(s.spatialReference,i,void 0,a),s=L(s,i)}catch{throw new c(Z,"Projection not supported")}return{extent:s,spatialReference:i,featureType:n}}async function pe(r,t,e,a={}){let{typeName:o}=t,[n,i]=await Promise.allSettled([me(r.operations.DescribeFeatureType.url,o,a),ce(r,o,e,a)]),s=b=>new c(_,`An error occurred while getting info about the feature type '${o}'`,{error:b});if(n.status==="rejected")throw s(n.reason);if(i.status==="rejected")throw s(i.reason);let{fields:u,errors:p}=n.value??{},l=n.value?.geometryType||i.value?.geometryType,f=i.value?.swapXY??!1;if(l==null)throw new c(W,`The geometry type could not be determined for type '${o}`,{typeName:o,geometryType:l,fields:u,errors:p});return x(m({},le(u??[])),{geometryType:l,swapXY:f})}function le(r){let t=r.find(a=>a.type==="geometry"),e=r.find(a=>a.type==="oid");return r=r.filter(a=>a.type!=="geometry"),e||(e=new y({name:j,type:"oid",alias:j}),r.unshift(e)),{geometryField:t?.name??null,objectIdField:e.name,fields:r}}async function ce(r,t,e,a={}){let o,n=!1,[i,s]=await Promise.all([ge(r.operations.GetFeature.url,t,e,r.operations.GetFeature.outputFormat,x(m({},a),{count:1})),d(r.operations.GetFeature.url,{responseType:"text",query:X(t,e,void 0,x(m({},a),{count:1})),signal:a?.signal})]),u=i.type==="FeatureCollection"&&i.features[0]?.geometry;if(u){let p;switch(o=M.fromJSON(U(u.type)),u.type){case"Point":p=u.coordinates;break;case"LineString":case"MultiPoint":p=u.coordinates[0];break;case"MultiLineString":case"Polygon":p=u.coordinates[0][0];break;case"MultiPolygon":p=u.coordinates[0][0][0]}let l=/<[^>]*pos[^>]*> *(-?\d+(?:\.\d+)?) (-?\d+(?:\.\d+)?)/.exec(s.data);if(l){let f=p[0].toFixed(3),b=p[1].toFixed(3),z=parseFloat(l[1]).toFixed(3);f===parseFloat(l[2]).toFixed(3)&&b===z&&(n=!0)}}return{geometryType:o,swapXY:n}}async function me(r,t,e){return fe(t,(await d(r,{responseType:"text",query:m({SERVICE:"WFS",REQUEST:"DescribeFeatureType",VERSION:w,TYPENAME:t,TYPENAMES:t},e?.customParameters),signal:e?.signal})).data)}function fe(r,t){let{name:e}=S(r),a=Y(t);q(a);let o=T(g(a.firstElementChild,{element:n=>n}),n=>n.getAttribute("name")===e);if(o!=null){let n=o.getAttribute("type"),i=n?T(g(a.firstElementChild,{complexType:s=>s}),s=>s.getAttribute("name")===S(n).name):T(g(o,{complexType:s=>s}),()=>!0);if(i)return de(i)}throw new c($,`Type '${r}' not found in document`,{document:new XMLSerializer().serializeToString(a)})}var ye=new Set(["objectid","fid"]);function de(r){let t=[],e=[],a,o=g(r,{complexContent:{extension:{sequence:{element:n=>n}}}});for(let n of o){let i=n.getAttribute("name");if(!i)continue;let s,u;if(n.hasAttribute("type")?s=S(n.getAttribute("type")).name:F(n,{simpleType:{restriction:f=>(s=S(f.getAttribute("base")).name,{maxLength:b=>{u=+b.getAttribute("value")}})}}),!s)continue;let p=n.getAttribute("nillable")==="true",l=!1;switch(s.toLowerCase()){case"integer":case"nonpositiveinteger":case"negativeinteger":case"long":case"int":case"short":case"byte":case"nonnegativeinteger":case"unsignedlong":case"unsignedint":case"unsignedshort":case"unsignedbyte":case"positiveinteger":e.push(new y({name:i,alias:i,type:"integer",nullable:p,length:h("integer")}));break;case"float":case"double":case"decimal":e.push(new y({name:i,alias:i,type:"double",nullable:p,length:h("double")}));break;case"boolean":case"string":case"gyearmonth":case"gyear":case"gmonthday":case"gday":case"gmonth":case"anyuri":case"qname":case"notation":case"normalizedstring":case"token":case"language":case"idrefs":case"entities":case"nmtoken":case"nmtokens":case"name":case"ncname":case"id":case"idref":case"entity":case"duration":case"time":e.push(new y({name:i,alias:i,type:"string",nullable:p,length:u??h("string")}));break;case"datetime":case"date":e.push(new y({name:i,alias:i,type:"date",nullable:p,length:u??h("date")}));break;case"pointpropertytype":a="point",l=!0;break;case"multipointpropertytype":a="multipoint",l=!0;break;case"curvepropertytype":case"multicurvepropertytype":case"multilinestringpropertytype":a="polyline",l=!0;break;case"surfacepropertytype":case"multisurfacepropertytype":case"multipolygonpropertytype":a="polygon",l=!0;break;case"geometrypropertytype":case"multigeometrypropertytype":l=!0,t.push(new c(W,`geometry type '${s}' is not supported`,{type:new XMLSerializer().serializeToString(r)}));break;default:t.push(new c(B,`Unknown field type '${s}'`,{type:new XMLSerializer().serializeToString(r)}))}l&&e.push(new y({name:i,alias:i,type:"geometry",nullable:p}))}for(let n of e)if(n.type==="integer"&&!n.nullable&&ye.has(n.name.toLowerCase())){n.type="oid";break}return{geometryType:a,fields:e,errors:t}}async function ge(r,t,e,a,o){let{data:n}=await d(r,{responseType:"text",query:X(t,e,a,o),signal:o?.signal});n=n.replaceAll(/": +(-?\d+),(\d+)(,)?/g,'": $1.$2$3');try{return JSON.parse(n)}catch(i){throw new c(K,"Error while parsing the\xA0response",{response:n,error:i})}}function X(r,t,e,a){let o=typeof t=="number"?t:t.wkid;return m({SERVICE:"WFS",REQUEST:"GetFeature",VERSION:w,TYPENAMES:r,OUTPUTFORMAT:e,SRSNAME:"EPSG:"+o,STARTINDEX:a?.startIndex,COUNT:a?.count},a?.customParameters)}async function De(r,t,e){let a=await d(r,{responseType:"text",query:m({SERVICE:"WFS",REQUEST:"GetFeature",VERSION:w,TYPENAMES:t,RESULTTYPE:"hits"},e?.customParameters),signal:e?.signal}),o=/numberMatched=["'](?<numberMatched>\d+)["']/gi.exec(a.data);if(o?.groups)return+o.groups.numberMatched}function Y(r){return new DOMParser().parseFromString(r.trim(),"text/xml")}function S(r){let[t,e]=r.split(":");return{prefix:e?t:"",name:e??t}}function we(r){let t=r.firstElementChild?.getAttribute("version");if(t&&t!==w)throw new c(ee,`Unsupported WFS version ${t}. Supported version: ${w}`)}function q(r){let t="",e="";if(F(r.firstElementChild,{Exception:a=>(t=a.getAttribute("exceptionCode"),{ExceptionText:o=>{e=o.textContent}})}),t)throw new c(`wfs-layer:${t}`,e)}function be(r,t,e){let a={wkid:t.defaultSpatialReference},o=e?.wkid!=null?{wkid:e.wkid}:a;return{spatialReference:o,getFeatureSpatialReference:G(r)||o.wkid&&t.supportedSpatialReferences.includes(o.wkid)?{wkid:o.wkid}:{wkid:t.defaultSpatialReference}}}export{j as a,Ie as b,se as c,Le as d,le as e,ge as f,De as g,be as h};
