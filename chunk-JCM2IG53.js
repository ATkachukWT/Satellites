import{a as L,b as g,c as U,d as C,e as P,f as A,g as G,h as _,i as D}from"./chunk-VDP755DS.js";import{a as m}from"./chunk-FQTXYWH5.js";import"./chunk-KLXERNY4.js";import"./chunk-GWZ4F32U.js";import{b as $,c as F}from"./chunk-BEYU5OIP.js";import{b as M}from"./chunk-UO5Q6C3A.js";import{d as R,e as f,f as I,g as y}from"./chunk-K27EVVBH.js";import{n as J}from"./chunk-YQGS4EZO.js";import"./chunk-TPFJWNIU.js";import"./chunk-P25RU3X5.js";import"./chunk-XRRQM4E2.js";import"./chunk-GWBRHLNH.js";import"./chunk-BOVYXYHK.js";import"./chunk-JGEVVXD4.js";import"./chunk-B3FO6PT7.js";import"./chunk-C4UMJHQC.js";import"./chunk-BCREO4Q5.js";import"./chunk-LXFQWIWE.js";import"./chunk-QT6UNBJP.js";import"./chunk-XZIOXVVJ.js";import"./chunk-5RAXVJQI.js";import"./chunk-EXJYW3PC.js";import"./chunk-SXQPBCOX.js";import"./chunk-LFH24RLM.js";import"./chunk-Z5Q7KLA4.js";import"./chunk-X4LNX4BR.js";import"./chunk-4XZ6X7MQ.js";import"./chunk-WLHY3MMA.js";import"./chunk-KGVXGH6H.js";import"./chunk-ARRCN5K3.js";import"./chunk-LXQPIAN7.js";import"./chunk-FTDD7QBB.js";import"./chunk-DB3UIQCU.js";import"./chunk-SBHKMV3P.js";import"./chunk-R4A63S45.js";import{s as p}from"./chunk-ETE32IYO.js";import"./chunk-ONUGDWDK.js";import"./chunk-SG7CQU4O.js";import"./chunk-QHVIRF5H.js";import"./chunk-WZDN6K3C.js";import"./chunk-QGVBCWUY.js";import"./chunk-OJQ73TPF.js";import"./chunk-354SCPDU.js";import"./chunk-OVHPPCBL.js";import"./chunk-IYZFKXJ6.js";import"./chunk-CKJ56T2Q.js";import"./chunk-SNFOAZZQ.js";import"./chunk-F6JAWRPN.js";import{t as u}from"./chunk-UHRSAPGQ.js";import{h as O,j as x,w as N}from"./chunk-V76GWARL.js";import"./chunk-N2WTMF3X.js";var v="Feature Service",T="feature-layer-utils",ae=`${T}-save`,te=`${T}-save-as`,d=`${T}-saveall`,h=`${T}-saveall-as`;function S(e){return{isValid:J(e)&&(!("dynamicDataSource"in e)||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function b(e,a){let t=M(e,"portal-item");return a?.isTable&&(t.layerContainerType="tables"),t}function W(e){let a=b(e),t=b(e);return t.layerContainerType="tables",{forLayers:a,forTables:t}}function z(e){let a=[],t=[];for(let{layer:r,layerJSON:n}of e)r.isTable?t.push(n):a.push(n);return{layers:a,tables:t}}function j(e){return z([e])}async function q(e,a){return/\/\d+\/?$/.test(e.url)?j(a[0]):V(a,e)}async function V(e,a){if(e.reverse(),!a)return z(e);let t=await re(a,e);for(let r of e)H(r.layer,r.layerJSON,t);return ne(t,e),t}async function re(e,a){let t=await e.fetchData("json");if(se(t))return t;t||={},oe(t);let{layer:{url:r,customParameters:n,apiKey:s}}=a[0];return await le(t,{url:r??"",customParameters:n,apiKey:s},a.map(o=>o.layer.layerId)),t}function se(e){return!!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}function oe(e){e.layers||=[],e.tables||=[]}function ne(e,a){let t=[],r=[];for(let{layer:n}of a){let{isTable:s,layerId:o}=n;s?r.push(o):t.push(o)}K(e.layers,t),K(e.tables,r)}function K(e,a){if(e.length<2)return;let t=[];for(let{id:r}of e)t.push(r);O(t.sort(Y),a.slice().sort(Y))&&e.sort((r,n)=>{let s=a.indexOf(r.id),o=a.indexOf(n.id);return s<o?-1:s>o?1:0})}function Y(e,a){return e<a?-1:e>a?1:0}async function le(e,a,t){let{url:r,customParameters:n,apiKey:s}=a,{serviceJSON:o,layersJSON:l}=await $(r,{customParameters:n,apiKey:s}),i=k(e.layers,o.layers,t),c=k(e.tables,o.tables,t);e.layers=i.itemResources,e.tables=c.itemResources;let w=[...i.added,...c.added],ee=l?[...l.layers,...l.tables]:[];await ie(e,w,r,ee)}function k(e,a,t){let r=x(e,a,(s,o)=>s.id===o.id);e=e.filter(s=>!r.removed.some(o=>o.id===s.id));let n=r.added;return n.forEach(({id:s})=>{e.push({id:s})}),{itemResources:e,added:n.filter(({id:s})=>!t.includes(s))}}async function ie(e,a,t,r){let n=await ce(a),s=a.map(({id:o,type:l})=>new(n.get(l))({url:t,layerId:o,sourceJSON:r.find(({id:i})=>i===o)}));await Promise.allSettled(s.map(o=>o.load())),s.forEach(o=>{let{layerId:l,loaded:i,defaultPopupTemplate:c}=o;if(!i||c==null)return;let w={id:l,popupInfo:c.toJSON()};o.operationalLayerType!=="ArcGISFeatureLayer"&&(w.layerType=o.operationalLayerType),H(o,w,e)})}async function ce(e){let a=[];e.forEach(({type:n})=>{switch(F(n)){case"CatalogLayer":a.push(import("./chunk-7RECWS2R.js").then(s=>s.default));break;case"FeatureLayer":a.push(import("./chunk-KD7CC3OV.js").then(s=>s.default));break;case"OrientedImageryLayer":a.push(import("./chunk-MXUZGRDU.js").then(s=>s.default))}});let t=await Promise.all(a),r=new Map;return e.forEach(({type:n},s)=>{r.set(n,t[s])}),r}function H(e,a,t){e.isTable?B(t.tables,a):B(t.layers,a)}function B(e,a){let t=e.findIndex(({id:r})=>r===a.id);t===-1?e.push(a):e[t]=a}function Q(e,a){if(!e.length)throw new u(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function ue(e,a){let t=e.map(r=>r.portalItem.id);if(new Set(t).size>1)throw new u(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function X(e,a){let t=e.map(r=>r.layerId);if(new Set(t).size!==t.length)throw new u(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function ye(e){Q(e,d),await Promise.all(e.map(a=>a.load()));for(let a of e)L(a,d,S),U({layer:a,itemType:v,errorNamePrefix:d});ue(e,d),X(e,d)}function E(e,a){let t=0,r=0,n=0;for(let{layerType:s}of[...a.layers,...a.tables])switch(s){case"OrientedImageryLayer":t++;break;case"SubtypeGroupLayer":r++;break;case"SubtypeGroupTable":n++}f(e,y.ORIENTED_IMAGERY_LAYER,t>0),f(e,y.SUBTYPE_GROUP_LAYER,r>0),f(e,y.SUBTYPE_GROUP_TABLE,n>0)}function Z(e,a,t){R(a,y.METADATA),f(a,y.MULTI_LAYER,e.length>1),f(a,y.SINGLE_LAYER,e.length===1),f(a,y.TABLE,t.tables.length>0&&t.layers.length===0),E(a,t)}async function fe(e,a,t){E(a,t)}async function pe(e,a,t){let{url:r,layerId:n,title:s,fullExtent:o,isTable:l}=e,i=p(r);a.url=(i?.serverType==="FeatureServer"?r:`${r}/${n}`)??null,a.title||=s,a.extent=null,l||o==null||(a.extent=await I(o)),Z([e],a,t)}function me(e,a){for(let s of e){let o=s.parsedUrl.path,l=p(o);if(!l?.url.path)throw new u(`${a}:invalid-parameters`,g(s,`has unsupported url pattern: ${o}`),{layer:s});let c=l?.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new u(`${a}:invalid-parameters`,g(s,`has unsupported server type: ${c}`),{layer:s});if(c==="MapServer"&&e.length>1)throw new u(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}let t=p(e[0].parsedUrl.path),r=t?.url.path;if(!e.every(s=>p(s.parsedUrl.path)?.url.path===r))throw new u(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function de(e){Q(e,h),await Promise.all(e.map(a=>a.load()));for(let a of e)L(a,h,S);me(e,h),X(e,h)}function he(e,a){E(e,a),A(e)}async function we(e,a,t){let r=0;for(let{isTable:o}of e)o||r++;let n=e[0].parsedUrl.path,s=p(n);if(a.url=s?.serverType==="FeatureServer"?s.url.path:n,a.title||=s.title,a.extent=null,r>0){let o=e.map(l=>l.fullExtent).filter(N).reduce((l,i)=>l.clone().union(i));o&&(a.extent=await I(o))}Z(e,a,t),A(a)}async function Oe(e,a){return _({layer:e,itemType:v,validateLayer:S,createJSONContext:t=>b(t,e),createItemData:(t,r)=>q(r,[t]),errorNamePrefix:ae,setItemProperties:fe},a)}async function xe(e,a){await ye(e);let t=e[0].portalItem,r=W(t),n=await Promise.all(e.map(o=>P(o,o.isTable?r.forTables:r.forLayers,a))),s=await q(t,e.map((o,l)=>({layer:o,layerJSON:n[l]})));return he(t,s),await t.update({data:s}),await Promise.all(e.slice(1).map(o=>o.portalItem.reload())),m(r.forLayers),m(r.forTables),t.clone()}async function Ne(e,a,t){return D({layer:e,itemType:v,validateLayer:S,createJSONContext:r=>b(r,e),createItemData:(r,n)=>Promise.resolve(j(r)),errorNamePrefix:te,newItem:a,setItemProperties:pe},t)}async function $e(e,a,t){await de(e);let r=C({itemType:v,errorNamePrefix:h,newItem:a}),n=W(r),s=await Promise.all(e.map(l=>P(l,l.isTable?n.forTables:n.forLayers,t))),o=await V(e.map((l,i)=>({layer:l,layerJSON:s[i]})));await we(e,r,o),await G(r,o,t);for(let l of e)l.portalItem=r.clone();return m(n.forLayers),m(n.forTables),r}export{Oe as save,xe as saveAll,$e as saveAllAs,Ne as saveAs};
