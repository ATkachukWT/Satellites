import{a as we,d as yt,e as Se,f as ve,g as gt}from"./chunk-3ZN3HQ7V.js";import{a as ge,c as Ze,d as et,e as lt,f as Re,h as ct,i as ut,j as be,k as mt,l as Ie,m as ht,n as ft,o as dt,p as pt}from"./chunk-53QT4ZXE.js";import{a as he,b as tt,c as it,f as rt,g as xe,h as nt,i as fe,j as st,l as ot,m as at}from"./chunk-Y4TT5CQV.js";import{a as ee,b as Le,d as Ue}from"./chunk-KVIE5PSM.js";import{b as te,d as Ge,f as pe,g as Y,h as ie,i as re,j as ue,k as Ae,l as qe,m as Ve,n as ye}from"./chunk-KMLF2ICK.js";import{U as je,_ as Ke,l as ze,m as Oe,p as We}from"./chunk-IPR4SOKY.js";import{C as Ee,D as ce,G as $e,H as Qe,I as Xe,O as Ye,g as Me,x as le}from"./chunk-VKKXXOQY.js";import{a as Pe}from"./chunk-47CBJZNC.js";import{e as me}from"./chunk-SVJ5AK5B.js";import{a as Ne}from"./chunk-WPZN772I.js";import{a as He,b as K}from"./chunk-6YRWGF73.js";import{a as Ce}from"./chunk-NRBJLISB.js";import{p as Be}from"./chunk-B3FO6PT7.js";import{m as $}from"./chunk-LFH24RLM.js";import{n as B}from"./chunk-Z5Q7KLA4.js";import{a as De}from"./chunk-X4LNX4BR.js";import{a as ae}from"./chunk-4XZ6X7MQ.js";import{n as Je}from"./chunk-KGVXGH6H.js";import{E as oe,x as se}from"./chunk-ETE32IYO.js";import{f as ke}from"./chunk-SG7CQU4O.js";import{H as x}from"./chunk-QHVIRF5H.js";import{I as X,o as ne,x as Fe}from"./chunk-WZDN6K3C.js";import{a as y}from"./chunk-QGVBCWUY.js";import{A as Te}from"./chunk-CKJ56T2Q.js";import{r as Z,t as z}from"./chunk-UHRSAPGQ.js";import{a as w,b as S}from"./chunk-N2WTMF3X.js";var xt=8,vt=256,_t=0,v=class extends ke{constructor(){super(...arguments),this._tileFetchQueue=new Pe({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,S(w({},t.options),{signal:i}))}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t=S(w({},t),{ioConfig:w({resolution:null,bandIds:null,sampling:"closest",tileInfo:K.create()},t.ioConfig)})),t}get _isGlobalWrappableSource(){let{rasterInfo:t}=this,i=re(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){let{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){this._set("rasterJobHandler",t),this.datasetFormat==="Function"&&this.primaryRasters?.rasters?.forEach(i=>i.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+_t++}set url(t){this._set("url",se(t,Z.getLogger(this)))}async open(t){return this._openPromise??=te().then(()=>this._open(t)),this._openPromise}async fetchTile(t,i,s,e={}){let r=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(t,i,s,r);return e=w({noClip:!0},e),this.fetchPixels(o,r.size[0],r.size[1],e)}async identify(t,i={}){t=ne(B,t).clone().normalize();let{multidimensionalDefinition:s,timeExtent:e}=i,{rasterInfo:r}=this,{hasMultidimensionalTranspose:o,multidimensionalInfo:n}=r,{transposedVariableName:a}=i,l=n!=null&&o&&(e!=null||fe(s));l&&!a&&(a=s!=null&&s.length>0?s[0].variableName??void 0:n.variables[0].name,i=S(w({},i),{transposedVariableName:a})),i=this._getRequestOptionsWithSliceId(i);let{spatialReference:c,extent:m}=r,{datumTransformation:h}=i,u=pe(t,c,h);if(!m.intersects(u))return{location:u,value:null};if(r.transform!=null){let D=r.transform.inverseTransform(u);if(!r.nativeExtent.intersects(D))return{location:D,value:null};u=D}let d=0,p=a!=null&&n!=null&&r.hasMultidimensionalTranspose;if(this.datasetFormat==="Function"){let D=this.primaryRasters.rasters[0];if(p)return D.identify(u,i);let{pixelSize:j}=r,_=3,J=j.x*_/2,T=j.y*_/2,H=new $({xmin:u.x-J,xmax:u.x+J,ymin:u.y-T,ymax:u.y+T,spatialReference:c}),N={interpolation:"nearest",multidimensionalDefinition:s,sliceId:i.sliceId},{pixelBlock:M}=await D.fetchPixels(H,_,_,N),{pixelBlock:F}=await this.fetchPixels(H,_,_,N);if(M==null)return{location:u,value:null};let k=Math.floor(_*_*.5),A=!M.mask||M.mask[k]?M.pixels.map(C=>C[k]):null,U;return F!=null&&(U=!F.mask||F.mask[k]?F.pixels.map(C=>C[k]):void 0),{location:u,value:A,processedValue:U,pyramidLevel:0}}if(!p){if(i.srcResolution)d=ye(i.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(d=await this.computeBestPyramidLevelForLocation(t,i),d==null)return{location:u,value:null}}let b=this.identifyPixelLocation(u,d,null,p);if(b===null)return{location:u,value:null};let{row:g,col:f,rowOffset:I,colOffset:R,blockWidth:P}=b,V=a??i.sliceId,E=we(this.rasterId,V),O=`${d}/${g}/${f}`,W=Se(E,null,O);W==null&&(W=this.fetchRawTile(d,g,f,i),ve(E,null,O,W));let L=await W;if(!L?.pixels?.length)return{location:u,value:null};let G=I*P+R;return this._processIdentifyResult(L,{srcLocation:u,position:G,pyramidLevel:d,useTransposedTile:!!p,requestSomeSlices:l,identifyOptions:i})}async fetchPixels(t,i,s,e={}){t=Ve(t),e=this._getRequestOptionsWithSliceId(e);let{_hasNoneOrGCSShiftTransform:r}=this;if(e.requestRawData&&r)return this._fetchPixels(t,i,s,e);let o=re(t.spatialReference),n=ue(t);if(o==null||n===0||n===1&&this._isGlobalWrappableSource&&r)return this._fetchPixels(t,i,s,e);if(n>=3)return{extent:t,pixelBlock:null};let a=[],{xmin:l,xmax:c}=t,m=Math.round(o/(c-l)*i),h=m-Math.round((o/2-l)/(c-l)*i),u=0,d=[];for(let f=0;f<=n;f++){let I=new $({xmin:f===0?l:-o/2,xmax:f===n?c-o*f:o/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),R=f===0?m-h:f===n?i-u:m;u+=R,d.push(R);let P=e.disableWrapAround&&f>0?null:this._fetchPixels(I,R,s,e);a.push(P)}let p=(await Promise.all(a)).map(f=>f?.pixelBlock),b=null,g={width:i,height:s};return this.rasterJobHandler?b=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:g,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:d},e)).pixelBlock:b=le(p,g,{blockWidths:d}),{extent:t,srcExtent:Y(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:b}}async fetchRawPixels(t,i,s,e={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};let r=await this._fetchRawTiles(t,i,s,e),{nativeExtent:o,nativePixelSize:n,storageInfo:a}=this.rasterInfo,l=2**t,c=n.x*l,m=n.y*l,h=new $({xmin:o.xmin+c*i.x,xmax:o.xmin+c*(i.x+s.width-1),ymin:o.ymax-m*(i.y+s.height-1),ymax:o.ymax-m*i.y,spatialReference:o.spatialReference});if(!r)return{extent:h,srcExtent:h,pixelBlock:null};let{pixelBlocks:u,mosaicSize:d}=r;if(u.length===1&&u[0]!=null&&u[0].width===s.width&&u[0].height===s.height)return{extent:h,srcExtent:h,pixelBlock:r.pixelBlocks[0]};let p=t>0?a.pyramidBlockWidth:a.blockWidth,b=t>0?a.pyramidBlockHeight:a.blockHeight,g={x:i.x%p,y:i.y%b},f;return this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:d,destDimension:s,clipOffset:g,clipSize:s,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:f=le(u,d,{clipOffset:g,clipSize:s}),{extent:h,srcExtent:h,pixelBlock:f}}fetchRawTile(t,i,s,e){throw new z("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Y(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?ze(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,s=0){let{customFetchParameters:e}=this.ioConfig,{range:r,query:o,headers:n}=i;s=s??i.retryCount??this.ioConfig.retryCount;let a=r?{Range:`bytes=${r.from}-${r.to}`}:null;try{return await oe(t,S(w({},i),{query:w(w({},o),e),headers:w(w({},n),a)}))}catch(l){if(s>0)return s--,this.request(t,i,s);throw l}}getSliceIndex(t){let{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:ot(t,i)}getTileExtentFromTileInfo(t,i,s,e){let r=e.lodAt(t);return this.getTileExtent({x:r.resolution,y:r.resolution},i,s,e.origin,e.spatialReference,e.size)}updateTileInfo(){let{storageInfo:t,spatialReference:i,extent:s,pixelSize:e}=this.rasterInfo,{pyramidResolutions:r}=t;if(!t.tileInfo){let o=[],n=t.maximumPyramidLevel||0,a=(e.x+e.y)/2,l=1/.0254*96*a;for(let m=0;m<=n&&(o.unshift(new He({level:n-m,resolution:a,scale:l})),m!==n);m++)if(r){let h=(r[m].x+r[m].y)/2;l*=h/a,a=h}else a*=2,l*=2;let c=new B({x:s.xmin,y:s.ymax,spatialReference:i});t.tileInfo=new K({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:o}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,s=512,e){let{width:r,height:o,nativeExtent:n,pixelSize:a,spatialReference:l}=t,c=new B({x:n.xmin,y:n.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(r,o))/Math.LN2-8)));let m=this.computeBlockBoundary(n,512,512,{x:n.xmin,y:n.ymax},[a],e);t.storageInfo=new We({blockWidth:i,blockHeight:s,pyramidBlockWidth:i,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:m})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,s,e,r,o=0,n=2){if(r.length===1&&o>0){r=[...r];let{x:m,y:h}=r[0];for(let u=0;u<o;u++)m*=n,h*=n,r.push({x:m,y:h})}let a=[],{x:l,y:c}=e;for(let m=0;m<r.length;m++){let{x:h,y:u}=r[m];a.push({minCol:Math.floor((t.xmin-l+.1*h)/i/h),maxCol:Math.floor((t.xmax-l-.1*h)/i/h),minRow:Math.floor((c-t.ymax+.1*u)/s/u),maxRow:Math.floor((c-t.ymin-.1*u)/s/u)})}return a}getPyramidPixelSize(t){let{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return i;if(s!=null&&s.length)return s[t-1];let r=e**t;return{x:i.x*r,y:i.y*r}}identifyPixelLocation(t,i,s,e){let{spatialReference:r,nativeExtent:o,storageInfo:n}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:c}=n,m=e&&c!=null?c.tileSize[0]:n.blockWidth,h=e&&c!=null?c.tileSize[1]:n.blockHeight,u=pe(t,r,s);if(!o.intersects(u)||i<0||i>a)return null;let d=this.getPyramidPixelSize(i),{x:p,y:b}=d,g=(l.y-u.y)/b/h,f=(u.x-l.x)/p/m,I=Math.min(h-1,Math.floor((g-Math.floor(g))*h)),R=Math.min(m-1,Math.floor((f-Math.floor(f))*m));return{pyramidLevel:i,row:Math.floor(g),col:Math.floor(f),rowOffset:I,colOffset:R,blockWidth:m,srcLocation:u}}getTileExtent(t,i,s,e,r,o){let[n,a]=o,l=e.x+s*n*t.x,c=l+n*t.x,m=e.y-i*a*t.y,h=m-a*t.y;return new $({xmin:l,xmax:c,ymin:h,ymax:m,spatialReference:r})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,s){let e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<i||e.maxCol<s||e.minRow>i||e.minCol>s}updateImageSpaceRasterInfo(t){let{pixelSize:i}=t,{width:s,height:e}=t,r=ae.WebMercator;t.spatialReference=r,t.extent=t.nativeExtent=new $({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-e,spatialReference:r}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new B({x:1,y:1,spatialReference:r});let{extent:o,storageInfo:n}=t;if(n){n.origin=new B({x:o.xmin,y:o.ymax,spatialReference:r});let{pyramidResolutions:a,tileInfo:l}=n;if(a&&a.forEach(c=>{c.x/=i.x,c.y/=i.y}),l){l.origin=n.origin;let c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((m,h)=>{m.resolution=c*2**h,m.scale=96*m.resolution/.0254})}}}async _fetchPixels(t,i,s,e={}){let r=ue(t);if(r>=2)return{extent:t,pixelBlock:null};let o=this._getSourceDataInfo(t,i,s,e),{pyramidLevel:n,srcResolution:a,srcExtent:l,srcWidth:c,srcHeight:m,ul:h}=o;if(c===0||m===0)return{extent:t,srcExtent:l,pixelBlock:null};let{rasterInfo:u}=this,d=u.transform,p=d?.type==="gcs-shift",b=re(t.spatialReference)!=null;!p&&b||(r=ue(o.srcExtent,p));let g=await this._fetchRawTiles(n,h,{width:c,height:m,wrapCount:r},e);if(!g)return{extent:t,srcExtent:l,pixelBlock:null};let f=u.storageInfo,I=n>0?f.pyramidBlockWidth:f.blockWidth,R=n>0?f.pyramidBlockHeight:f.blockHeight,{x:P,y:V}=u.pixelSize;if(n>0){let{pyramidResolutions:q,pyramidScalingFactor:St}=f;if(q!=null&&q[n-1])({x:P,y:V}=q[n-1]);else{let _e=St**n;P*=_e,V*=_e}}let E=u.spatialReference,O=new B({x:P,y:V,spatialReference:E}),W=I===c&&R===m&&h.x%I==0&&h.y%R==0,L=new B({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),G=!t.spatialReference.equals(E),D=E.isGeographic?1e-9:1e-4,{datumTransformation:j}=e;if(!G&&W&&g.pixelBlocks.length===1&&I===i&&R===s&&Tt(a,L,D))return{extent:t,srcExtent:l,srcTilePixelSize:O,pixelBlock:g.pixelBlocks[0]};let _=b&&re(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,J=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");J&&!this.rasterJobHandler&&await te();let T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:L.toJSON(),datumTransformation:j,rasterTransform:d,hasWrapAround:r>0||_,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:J},e):qe({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:L,datumTransformation:j,rasterTransform:d,hasWrapAround:r>0||_,isAdaptive:!1,includeGCSGrid:J}),H,N=!e.requestRawData,M={rows:T.spacing[0],cols:T.spacing[1]},F=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(n,g.extent.xmin):void 0,{pixelBlocks:k,mosaicSize:A,isPartiallyFilled:U}=g,C=null;if(this.rasterJobHandler)({pixelBlock:H,localNorthDirections:C}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:k,srcMosaicSize:A,destDimension:N?{width:i,height:s}:null,coefs:N?T.coefficients:null,sampleSpacing:N?M:null,projectDirections:J,gcsGrid:J?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:F,blockWidths:null},e));else{let q=le(k,A,{alignmentInfo:F});H=N?ce(q,{width:i,height:s},T.coefficients,M,e.interpolation):q,J&&T.gcsGrid&&(C=Ee({width:i,height:s},T.gcsGrid),H=Qe(H,this.rasterInfo.dataType,C))}return e.requestRawData||J?{extent:t,srcExtent:l,srcTilePixelSize:O,pixelBlock:H,transformGrid:T,localNorthDirections:C,isPartiallyFilled:U}:{extent:t,srcExtent:l,srcTilePixelSize:O,pixelBlock:H}}async _fetchRawTiles(t,i,s,e){let{origin:r,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:n,blockHeight:a}=this.getBlockWidthHeight(t),{x:l,y:c}=i,{width:m,height:h,wrapCount:u}=s,d=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(l-=e.buffer.cols,c-=e.buffer.rows,m+=2*e.buffer.cols,h+=2*e.buffer.rows);let p=0,b=0,g=0;u&&d!=null&&({worldColumnCountFromOrigin:b,originColumnOffset:g,rightPadding:p}=d,b*d.blockWidth-p>=l+m&&(p=0));let f=Math.floor(l/n),I=Math.floor(c/a),R=Math.floor((l+m+p-1)/n),P=Math.floor((c+h+p-1)/a),V=o[t];if(!V)return null;let{minRow:E,minCol:O,maxCol:W,maxRow:L}=V;if(u===0&&(P<E||R<O||I>L||f>W))return null;let G=new Array,D=!1,j=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let F=I;F<=P;F++)for(let k=f;k<=R;k++){let A=k;if(!e.disableWrapAround&&u&&d!=null&&b<=k&&(A=k-b-g),F>=E&&A>=O&&L>=F&&W>=A){let U=this._tileFetchQueue.push({pyramidLevel:t,row:F,col:A,options:e},{signal:e.signal});j?G.push(new Promise(C=>{U.then(q=>C(q)).catch(()=>{D=!0,C(null)})})):G.push(U)}else G.push(Promise.resolve(null))}if(G.length===0)return null;let _=await Promise.all(G),J={height:(P-I+1)*a,width:(R-f+1)*n},{spatialReference:T}=this.rasterInfo,H=this.getPyramidPixelSize(t),{x:N,y:M}=H;return{extent:new $({xmin:r.x+f*n*N,xmax:r.x+(R+1)*n*N,ymin:r.y-(P+1)*a*M,ymax:r.y-I*a*M,spatialReference:T}),pixelBlocks:_,mosaicSize:J,isPartiallyFilled:D}}_fetchRawTile(t,i,s,e){let r=this.rasterInfo.storageInfo.blockBoundary[t];if(!r)return Promise.resolve(null);let{minRow:o,minCol:n,maxCol:a,maxRow:l}=r;if(i<o||s<n||i>l||s>a)return Promise.resolve(null);let c=we(this.rasterId,e.sliceId),m=`${t}/${i}/${s}`,h=Se(c,e.registryId,m);if(h==null){let u=new AbortController;h=this.fetchRawTile(t,i,s,S(w({},e),{signal:u.signal})),ve(c,e.registryId,m,h,u),h.catch(()=>gt(c,e.registryId,m))}return e.signal&&Te(e,()=>{yt(c,e.registryId,m)}),h}_computeMagDirValues(t){let{bandCount:i,dataType:s}=this.rasterInfo;if(!(i===2&&s==="vector-magdir"||s==="vector-uv")||t?.length!==2||!t[0]?.length)return null;let e=t[0].length;if(s==="vector-magdir"){let l=t[1].map(c=>(c+360)%360);return[t[0],l]}let[r,o]=t,n=[],a=[];for(let l=0;l<e;l++){let[c,m]=$e([r[l],o[l]]);n.push(c),a.push(m)}return[n,a]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=Ae(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:w({startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform},this._rasterTileAlignmentInfo.pyramidsInfo[t])}_getSourceDataInfo(t,i,s,e={}){let r={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(r.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,r));let o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:n,srcHeight:a,pyramidLevel:l}=r,c=n/i,m=a/s,h=l<o&&c*m>=16,u=l===o&&this._requireTooManySrcTiles(n,a,i,s);if(h||u||n===0||a===0){let d=new B({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),p=Ge(d,this.rasterInfo.spatialReference,t,r.datumTransformation),b=!p||e.srcResolution&&p.x+p.y<e.srcResolution.x+e.srcResolution.y;if(h&&e.srcResolution&&b){let g=Math.round(Math.log(Math.max(c,m))/Math.LN2)-1;if(o-l+3>=g){let f=2**g;p={x:e.srcResolution.x*f,y:e.srcResolution.y*f}}}p&&(r.srcResolution=p,this._updateSourceDataInfo(t,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,i,s)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(t,i,s,e){let{tileInfo:r}=this.rasterInfo.storageInfo,o=Math.ceil(t/r.size[0])*Math.ceil(i/r.size[1]),n=t/s,a=i/e,l=Math.max(1,(s+e)/1024);return o>=vt*l||n>xt||a>xt}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;let{rasterInfo:s}=this,e=s.spatialReference,{srcResolution:r,datumTransformation:o}=i,{pyramidLevel:n,pyramidResolution:a,excessiveReading:l}=ye(r,s,this.ioConfig.sampling);if(l)return;let c=i.srcExtent||Y(t,e,o);if(c==null)return;let m=s.transform;m&&(c=m.inverseTransform(c)),i.srcExtent=c;let{x:h,y:u}=s.storageInfo.origin,d=Math.floor((c.xmin-h)/a.x+.1),p=Math.floor((u-c.ymax)/a.y+.1),b=Math.floor((c.xmax-h)/a.x-.1),g=Math.floor((u-c.ymin)/a.y-.1),f=c.width<.1*a.x?0:b-d+1,I=c.height<.1*a.y?0:g-p+1;i.pyramidLevel=n,i.pyramidResolution=a,i.srcWidth=f,i.srcHeight=I,i.ul={x:d,y:p}}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t=S(w({},t),{sliceId:this.getSliceIndex(t.multidimensionalDefinition)})),t}_processIdentifyResult(t,i){let{srcLocation:s,position:e,pyramidLevel:r,useTransposedTile:o}=i,n=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:s,value:null};let{multidimensionalInfo:a}=this.rasterInfo;if(a==null||!o){let g=t.pixels.map(R=>R[e]),f={location:s,value:g,pyramidLevel:r},I=this._computeMagDirValues(g.map(R=>[R]));return I?.length&&(f.magdirValue=I.map(R=>R[0])),f}let l=t.pixels.map(g=>g.slice(e*n,e*n+n)),c=this._computeMagDirValues(l),{requestSomeSlices:m,identifyOptions:h}=i,u=tt(a,h.transposedVariableName);if(m){let g=it(u,h.multidimensionalDefinition,h.timeExtent);l=l.map(f=>g.map(I=>f[I])),c=c?.map(f=>g.map(I=>f[I])),u=g.map(f=>u[f])}let d=t.noDataValues||this.rasterInfo.noDataValue,p={pixels:l,pixelType:t.pixelType},b;return d!=null&&(Me(p,d),b=p.mask),{location:s,value:null,dataSeries:u.map((g,f)=>{let I={value:b?.[f]===0?null:l.map(R=>R[f]),multidimensionalDefinition:g.multidimensionalDefinition.map(R=>new he(S(w({},R),{isSlice:!0})))};return c?.length&&(I.magdirValue=[c[0][f],c[1][f]]),I}),pyramidLevel:r}}};function Tt(t,i,s){return Math.abs(t.x-i.x)<s&&Math.abs(t.y-i.y)<s}y([x()],v.prototype,"_rasterTileAlignmentInfo",void 0),y([x()],v.prototype,"_tileFetchQueue",void 0),y([x({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),y([x({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),y([x()],v.prototype,"_openPromise",void 0),y([x()],v.prototype,"rasterJobHandler",null),y([x({readOnly:!0})],v.prototype,"rasterId",null),y([x(me)],v.prototype,"url",null),y([x({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),y([x({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),y([x()],v.prototype,"hasUniqueSourceStorageInfo",void 0),y([x()],v.prototype,"rasterInfo",void 0),y([x()],v.prototype,"ioConfig",void 0),y([x()],v.prototype,"sourceJSON",void 0),v=y([X("esri.layers.support.rasterDatasets.BaseRaster")],v);var Rt=v;var Ft=40,Q=class extends Rt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,s,e={}){let{rasters:r,rasterIds:o}=this.primaryRasters,n=!1,{interpolation:a}=e,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!e.requestRawData&&l&&(n=r.length===1&&!e.skipRasterFunction,e=S(w({},e),{interpolation:"bilinear",requestRawData:n}));let c=r.map(R=>R.fetchPixels(t,i,s,e)),m=await Promise.all(c),h=m.map(R=>R.pixelBlock),u=n||e.requestRawData?m.map(R=>R.srcTilePixelSize):null;if(e.skipRasterFunction||h.every(R=>R==null))return m[0];let d=m.find(R=>R.pixelBlock!=null)?.extent??t,p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:d,primaryPixelBlocks:h,primaryPixelSizes:u,primaryRasterIds:o}):this.rasterFunction.process({extent:d,primaryPixelBlocks:h,primaryPixelSizes:u,primaryRasterIds:o}),{transformGrid:b}=m[0];if(!n||p==null||b==null){let R=e.noClip?null:this.getClippingGeometry(d.spatialReference);return e.noClip||e.requestRawData||p==null||!R||(p=await ee(p,d,R)),S(w({},m[0]),{pixelBlock:p})}let g={rows:b.spacing[0],cols:b.spacing[1]},f;this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:i,height:s},coefs:b.coefficients,sampleSpacing:g,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:f=ce(p,{width:i,height:s},b.coefficients,g,a);let I=e.noClip?null:this.getClippingGeometry(t.spatialReference);return e.noClip||e.requestRawData||f==null||I==null||(f=await ee(f,t,I)),{extent:t,srcExtent:m[0].srcExtent,pixelBlock:f}}getClippingGeometry(t){let i=this._clippingGeometry.get("0");if(!t||!i)return i;let s=Pt(t),e=this._clippingGeometry.get(s);return e!=null||(e=t.equals(i.spatialReference)?i:ie(i,t),this._clippingGeometry.set(s,e)),e}async _open(t){let{rasterFunction:i}=this;this.primaryRasters?.rasters?.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(c=>c.rasterJobHandler=this.rasterJobHandler));let{rasters:s,rasterIds:e}=this.primaryRasters,r=s.map(c=>c.rasterInfo?void 0:c.open(t));await Promise.all(r);let o=s.map(({rasterInfo:c})=>c),n=i.bind({rasterInfos:o,rasterIds:e});if(i.rawSourceRasterInfos=o,!n.success||o.length===0)throw new z("raster-function:open",`cannot bind the function: ${n.error??""}`);let a=i.functionName==="Table"?i:i.functionArguments?.raster;a?.functionName==="Table"&&(i.rasterInfo.attributeTable=Ne.fromJSON(a.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();let l=o[0];this.hasUniqueSourceStorageInfo=o.length===1||o.slice(1).every(c=>kt(c,l)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){let t=this.rasterFunction.getClippingGeometries()[0],i=t?.clippingGeometry;if(i&&t.clippingType==="inside"){let{extent:s}=this.rasterInfo,{difference:e,densify:r}=await import("./chunk-FTLDMWA3.js"),o=r(Be.fromExtent(s),2*(s.width+s.height)/Ft);o=ie(o,i.spatialReference),i=e(o,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};y([x({type:String,json:{write:!0}})],Q.prototype,"datasetFormat",void 0),y([x()],Q.prototype,"tileType",void 0),y([x()],Q.prototype,"rasterFunction",void 0),y([x()],Q.prototype,"primaryRasters",void 0),Q=y([X("esri.layers.support.rasterDatasets.FunctionRaster")],Q);var bt=Q;function kt(t,i){let{storageInfo:s,pixelSize:e,spatialReference:r,extent:o}=t,{storageInfo:n,pixelSize:a,spatialReference:l,extent:c}=i;return e.x===a.x&&e.y===a.y&&r.equals(l)&&o.equals(c)&&s.blockHeight===n.blockHeight&&s.blockWidth===n.blockWidth&&s.maximumPyramidLevel===n.maximumPyramidLevel}function Pt(t){return String(t.wkid??t.wkt??t.wkt2)}var nr=t=>{let i=class extends t{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=e[0]?.raster?.datasetFormat==="Function"}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",se(e,Z.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;let{activePresetRendererName:e,presetRenderers:r}=this;return e?r?.find(({name:n})=>n===e)?.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,r,o){let n=r?.layerDefinition?.drawingInfo?.renderer;return dt(n,o)||void 0}async convertVectorFieldData(e,r){let{serviceRasterInfo:o}=this;if(e==null||!o)return null;let n=this._rasterJobHandler.instance,a=o.dataType;return n?n.convertVectorFieldData({pixelBlock:e,dataType:a},r):Xe(e,a)}async computeStatisticsHistograms(e,r){await this.load(r),e=ne(pt,e).clone();let{serviceRasterInfo:o}=this;if(o==null)throw new z("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");let{geometry:n}=e;if(n==null)throw new z("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let a=n,{spatialReference:l}=o;n.spatialReference.equals(l)||(await te(),a=n.type==="extent"?Y(n,l):ie(n,l));let c=e.pixelSize??new B({x:o.pixelSize.x,y:o.pixelSize.y,spatialReference:l}),{extent:m,width:h,height:u}=Le(o,a,c),d=await this.fetchPixels(m,h,u,S(w({},r),{interpolation:"nearest"}));if(d.pixelBlock==null)throw new z("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");let p=await ee(d.pixelBlock,m,a),b=this._rasterJobHandler.instance;return b?b.computeStatisticsHistograms({pixelBlock:p},r):je(p)}async createFlowMesh(e,r){let o=this._rasterJobHandler.instance;return o?o.createFlowMesh(e,r):Ye(e.meshType,e.simulationSettings,e.flowData,r.signal!=null?r.signal:new AbortController().signal)}normalizeRasterFetchOptions(e){let{multidimensionalInfo:r}=this.serviceRasterInfo??{};if(r==null)return e;let o=rt({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return S(w({},e),{multidimensionalDefinition:o})}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){let{loaded:e,symbolizer:r}=this;if(!e||!r||!this.renderer)return;let{rasterInfo:o}=this.raster,n=xe(o,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),a=n?.name,l=Ie(S(w({},this.renderer.toJSON()),{variableName:a}));if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(l))return;let c=this._rasterJobHandler.instance;c&&(r.rasterInfo=be(o,a),r.rendererJSON=l,r.bind(),await c.updateSymbolizer(r),this._cachedRendererJson=l)}async applyRenderer(e,r){let o=e?.pixelBlock;if(!(o!=null&&o.pixels&&o.pixels.length>0))return null;let n;await this.updateRenderer();let a=this._rasterJobHandler.instance,l=this.bandIds??[];return n=a?await a.symbolize(S(w({},e),{simpleStretchParams:r,bandIds:l})):this.symbolizer.symbolize(S(w({},e),{simpleStretchParams:r,bandIds:l})),n}getTileUrl(e,r,o){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${r}/${o}`:""}getCompatibleTileInfo(e,r,o=!1){if(!this.loaded||r==null)return null;if(o&&e.equals(this.spatialReference))return this.tileInfo;let n=Je(e);return K.create({size:256,spatialReference:e,origin:n?{x:n.origin[0],y:n.origin[1]}:{x:r.xmin,y:r.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,r,o,n={}){if(s(this),n.requestAsImageElement){let l=this.getTileUrl(e,r,o);return oe(l,{responseType:"image",query:w(w({},this.refreshParameters),this.raster.ioConfig.customFetchParameters),signal:n.signal}).then(c=>c.data)}let{serviceRasterInfo:a}=this;if(a.multidimensionalInfo!=null&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null){let l=n.tileInfo||a.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,r,o,l),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(n=S(w({},n),{buffer:{cols:1,rows:1}})),this.raster.fetchTile(e,r,o,n)}async fetchPixels(e,r,o,n={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),r=Math.round(r),o=Math.round(o),this.raster.fetchPixels(e,r,o,n))}async identify(e,r={}){await this.load();let{raster:o,serviceRasterInfo:n}=this;if(n?.multidimensionalInfo!=null&&!(n.hasMultidimensionalTranspose&&(fe(r.multidimensionalDefinition)||r.transposedVariableName||r.timeExtent))&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null)return{location:e,value:null};let a=this.multidimensionalSubset?.areaOfInterest;if(a&&!a.contains(e))throw new z("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return o.identify(e,r)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){let e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;let r=this.multidimensionalDefinition,o=r?.[0]?.variableName;return e.variables.some(n=>n.name===o&&(!r?.[0].dimensionName||n.dimensions.some(a=>a.name==="StdTime")))}getStandardTimeValue(e){return new Date(at(e)).toISOString()}getMultidimensionalSubsetVariables(e){let r=e??this.serviceRasterInfo?.multidimensionalInfo;return st(this.multidimensionalSubset,r)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=nt(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&this.raster.datasetFormat==="Function"&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;let e=new et;return this._rasterJobHandler.connectionPromise=e.initialize().then(async()=>{s(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.raster.datasetFormat==="Function"&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(this.interpolation==null){s(this);let{raster:e}=this,r=ut(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",r)}}_configDefaultRenderer(e="no"){s(this);let{rasterInfo:r}=this.raster,o=xe(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),n=o?.name,a=lt({variableName:n,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&r.bandCount>1&&(this.bandIds=a?.bandIds??mt(r)),!this.renderer||e==="override"){let h=ct(this.raster),u=a?.renderer??Re(r,{bandIds:this.bandIds,variableName:n,rasterFunctionColorRamp:h}),d=r.statistics,p=d&&d.length>0?d[0]:null,b=p?.max??0,g=p?.min??0;this.raster.datasetFormat==="WCSServer"&&u.type==="raster-stretch"&&(b>1e24||g<-1e24)&&(u.dynamicRangeAdjustment=!0,u.customStatistics=null,u.stretchType==="none"&&(u.stretchType="min-max")),this.renderer=u}let l=Ie(S(w({},this.renderer.toJSON()),{variableName:n})),c=be(r,n);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=c):this.symbolizer=new Ke({rendererJSON:l,rasterInfo:c});let m=this.symbolizer.bind();if(m.success){if(e==="auto"){let{colormap:h}=this.raster.rasterInfo,u=this.renderer;if(h!=null&&u.type==="raster-colormap"){let d=Re(this.raster.rasterInfo);JSON.stringify(d)!==JSON.stringify(u)&&this._configDefaultRenderer("override")}else if(u.type==="raster-stretch"){let d=this.bandIds?.length,p=u.customStatistics?.length;!u.dynamicRangeAdjustment&&p&&d&&p!==d&&this._configDefaultRenderer("override")}}}else Z.getLogger(this).warn("imagery-tile-mixin",m.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&this.raster.datasetFormat==="Function"){let m=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&m&&this._set("rasterFunction",ge.fromJSON(m)))}let e,r=this.raster,o=!1;r.datasetFormat==="Function"?(e=r.primaryRasters.rasters,r=e[0],o=!0):e=[r];let{rasterFunction:n}=this;if(n){let m={raster:r};e.length>1&&e.forEach(d=>m[d.url]=d);let h=Ue(n.functionDefinition?.toJSON()??n.toJSON(),m),u=new bt({rasterFunction:h});u.rasterJobHandler=this._rasterJobHandler.instance,await u.open(),this.raster=u}else this.raster=r,await r.open();if(this._cachedRendererJson=null,!o&&!n)return;let{bandIds:a}=this,{bandCount:l}=this.raster.rasterInfo,c=a?.length?a.some(m=>m>=l):l>=3;a&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}};function s(e){if(!e.raster||!e.serviceRasterInfo)throw new z("imagery-tile","no raster")}return y([x({clonable:!1})],i.prototype,"_cachedRendererJson",void 0),y([x({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),y([x({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),y([x({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),y([x({clonable:!1})],i.prototype,"_rasterJobHandler",void 0),y([x({clonable:!1})],i.prototype,"_rasterFunctionUpdatePromise",void 0),y([x({type:[Fe],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),y([x({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),y([x({json:{read:!1}})],i.prototype,"fullExtent",null),y([x({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Ce(Oe)],i.prototype,"interpolation",void 0),y([x()],i.prototype,"ioConfig",void 0),y([x({type:[he],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),y([x({type:Ze,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),y([x()],i.prototype,"raster",void 0),y([x({type:ge})],i.prototype,"rasterFunction",null),y([x()],i.prototype,"serviceRasterInfo",void 0),y([x()],i.prototype,"sourceJSON",void 0),y([x({readOnly:!0,type:ae,json:{read:!1}})],i.prototype,"spatialReference",void 0),y([x({type:K})],i.prototype,"tileInfo",void 0),y([x(me)],i.prototype,"url",null),y([x()],i.prototype,"renderer",null),y([x({types:ht,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){let e=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:ft,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],i.prototype,"internalRenderer",null),y([De("internalRenderer")],i.prototype,"readRenderer",null),y([x({clonable:!1})],i.prototype,"symbolizer",void 0),i=y([X("esri.layers.mixins.ImageryTileMixin")],i),i};function de(t,i){if(!t||!i)return[];let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";let e=[];if(i){let o=de(t,s);for(let n=0;n<o.length;n++)de(o[n],i).forEach(a=>e.push(a));return e}let r=t.getElementsByTagNameNS("*",s);if(!r||r.length===0)return[];for(let o=0;o<r.length;o++)e.push(r[o]||r.item(o));return e}function It(t,i){if(!t||!i)return null;let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";let e=de(t,s);return e.length>0?i?It(e[0],i):e[0]:null}function wt(t,i=null){let s=i?It(t,i):t,e;return s?(e=s.textContent||s.nodeValue,e?e.trim():null):null}function Jt(t,i){let s=de(t,i),e=[],r;for(let o=0;o<s.length;o++)r=s[o].textContent||s[o].nodeValue,r&&(r=r.trim(),r!==""&&e.push(r));return e}function lr(t,i=null){return wt(t,i)?.split(" ").map(e=>Number(e))??[]}function cr(t,i){return Jt(t,i).map(s=>Number(s))}function ur(t,i){let s=wt(t,i);return Number(s)}function mr(t,i){let s=t?.nodeName?.toLowerCase(),e=i.toLowerCase();return s.slice(s.lastIndexOf(":")+1)===e}function hr(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{Rt as a,bt as b,nr as c,de as d,It as e,wt as f,Jt as g,lr as h,cr as i,ur as j,mr as k,hr as l};
