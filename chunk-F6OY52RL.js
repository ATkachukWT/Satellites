import{a as F,b as G,c as I}from"./chunk-ITBK54KO.js";import{d as T}from"./chunk-KVIE5PSM.js";import{a as B,b as v,l as b}from"./chunk-KMLF2ICK.js";import{U as k,V as w,_ as E,l as h}from"./chunk-IPR4SOKY.js";import{A as N,B as J,C as g,D as P,H as z,I as D,O as R,h as s,x as O}from"./chunk-VKKXXOQY.js";import"./chunk-VU5W7W6Y.js";import"./chunk-I5V562B6.js";import"./chunk-77L5NP7A.js";import"./chunk-KAMRW6HF.js";import"./chunk-W26XKMAT.js";import"./chunk-NQWYPF77.js";import"./chunk-CWUY5SXW.js";import{b as x}from"./chunk-TPFJWNIU.js";import"./chunk-P25RU3X5.js";import"./chunk-XRRQM4E2.js";import"./chunk-GWBRHLNH.js";import"./chunk-RJWOVI3M.js";import{a as y}from"./chunk-NRBJLISB.js";import"./chunk-PTZYZULI.js";import"./chunk-NMLYCCKN.js";import"./chunk-RSDQHAJX.js";import"./chunk-BOVYXYHK.js";import"./chunk-FENRIY2T.js";import"./chunk-JGEVVXD4.js";import"./chunk-B3FO6PT7.js";import"./chunk-C4UMJHQC.js";import"./chunk-BCREO4Q5.js";import"./chunk-LXFQWIWE.js";import"./chunk-QT6UNBJP.js";import"./chunk-XZIOXVVJ.js";import{m as a}from"./chunk-LFH24RLM.js";import{n as S}from"./chunk-Z5Q7KLA4.js";import"./chunk-X4LNX4BR.js";import"./chunk-4XZ6X7MQ.js";import"./chunk-WLHY3MMA.js";import"./chunk-KGVXGH6H.js";import"./chunk-ARRCN5K3.js";import"./chunk-DB3UIQCU.js";import"./chunk-SBHKMV3P.js";import"./chunk-R4A63S45.js";import"./chunk-ETE32IYO.js";import"./chunk-ONUGDWDK.js";import"./chunk-SG7CQU4O.js";import"./chunk-QHVIRF5H.js";import{I as d}from"./chunk-WZDN6K3C.js";import{a as f}from"./chunk-QGVBCWUY.js";import"./chunk-OJQ73TPF.js";import"./chunk-354SCPDU.js";import"./chunk-OVHPPCBL.js";import"./chunk-IYZFKXJ6.js";import"./chunk-CKJ56T2Q.js";import"./chunk-SNFOAZZQ.js";import"./chunk-F6JAWRPN.js";import"./chunk-UHRSAPGQ.js";import"./chunk-V76GWARL.js";import{a as l,b as c}from"./chunk-N2WTMF3X.js";var p,m=p=class extends F{constructor(){super(...arguments),this.type="identity"}clone(){return new p}};f([y({IdentityXform:"identity"})],m.prototype,"type",void 0),m=p=f([d("esri.layers.support.rasterTransforms.IdentityTransform")],m);var j=m;var L={GCSShiftXform:G,IdentityXform:j,PolynomialXform:I};function A(n){if(!n?.type)return null;let e=L[n?.type];if(e){let r=new e;return r.read(n),r}return null}var H=class{convertVectorFieldData(t){let e=s.fromJSON(t.pixelBlock),r=D(e,t.type);return Promise.resolve(r!=null?r.toJSON():null)}computeStatisticsHistograms(t){let e=s.fromJSON(t.pixelBlock),r=k(e);return Promise.resolve(r)}async decode(t){let e=await h(t.data,t.options);return e&&e.toJSON()}symbolize(t){t.pixelBlock=s.fromJSON(t.pixelBlock),t.extent=t.extent?a.fromJSON(t.extent):null;let e=this.symbolizer.symbolize(t);return Promise.resolve(e!=null?e.toJSON():null)}async updateSymbolizer(t){this.symbolizer=E.fromJSON(t.symbolizerJSON),t.histograms&&this.symbolizer?.rendererJSON.type==="rasterStretch"&&(this.symbolizer.rendererJSON.histograms=t.histograms)}async updateRasterFunction(t){this.rasterFunction=T(t.rasterFunctionJSON)}async process(t){let e=this.rasterFunction.process({extent:a.fromJSON(t.extent),primaryPixelBlocks:t.primaryPixelBlocks.map(r=>r!=null?s.fromJSON(r):null),primaryPixelSizes:t.primaryPixelSizes?.map(r=>r!=null?S.fromJSON(r):null),primaryRasterIds:t.primaryRasterIds});return e!=null?e.toJSON():null}stretch(t){let e=this.symbolizer.simpleStretch(s.fromJSON(t.srcPixelBlock),t.stretchParams);return Promise.resolve(e?.toJSON())}estimateStatisticsHistograms(t){let e=w(s.fromJSON(t.srcPixelBlock));return Promise.resolve(e)}split(t){let e=N(s.fromJSON(t.srcPixelBlock),t.tileSize,t.maximumPyramidLevel??0,t.useBilinear===!1);return e&&e.forEach((r,o)=>{e.set(o,r?.toJSON())}),Promise.resolve(e)}clipTile(t){let e=s.fromJSON(t.pixelBlock),r=J(c(l({},t),{pixelBlock:e}));return Promise.resolve(r?.toJSON())}async mosaicAndTransform(t){let e=t.srcPixelBlocks.map(u=>u?new s(u):null),r=O(e,t.srcMosaicSize,{blockWidths:t.blockWidths,alignmentInfo:t.alignmentInfo,clipOffset:t.clipOffset,clipSize:t.clipSize}),o,i=r;return t.coefs&&(i=P(r,t.destDimension,t.coefs,t.sampleSpacing,t.interpolation)),t.projectDirections&&t.gcsGrid&&(o=g(t.destDimension,t.gcsGrid),i=z(i,t.isUV?"vector-uv":"vector-magdir",o)),{pixelBlock:i?.toJSON(),localNorthDirections:o}}async createFlowMesh(t,e){let r={data:new Float32Array(t.flowData.buffer),mask:new Uint8Array(t.flowData.maskBuffer),width:t.flowData.width,height:t.flowData.height},{vertexData:o,indexData:i}=await R(t.meshType,t.simulationSettings,r,e.signal);return{result:{vertexBuffer:o.buffer,indexBuffer:i.buffer},transferList:[o.buffer,i.buffer]}}async getProjectionOffsetGrid(t){let e=a.fromJSON(t.projectedExtent),r=a.fromJSON(t.srcBufferExtent),o=null;t.datumTransformationSteps&&(o=new x({steps:t.datumTransformationSteps})),(t.includeGCSGrid||B(e.spatialReference,r.spatialReference,o))&&await v();let i=t.rasterTransform?A(t.rasterTransform):null;return b(c(l({},t),{projectedExtent:e,srcBufferExtent:r,datumTransformation:o,rasterTransform:i}))}};export{H as default};
