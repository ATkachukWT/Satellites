import{b as g}from"./chunk-NNX76JDG.js";import"./chunk-76O2P2CB.js";import{f as y}from"./chunk-FENRIY2T.js";import"./chunk-JGEVVXD4.js";import"./chunk-B3FO6PT7.js";import"./chunk-C4UMJHQC.js";import"./chunk-BCREO4Q5.js";import"./chunk-LXFQWIWE.js";import"./chunk-QT6UNBJP.js";import"./chunk-V2GNNIXD.js";import"./chunk-NSYL2RQJ.js";import"./chunk-ZVCMULXF.js";import"./chunk-KJULKTB5.js";import"./chunk-LACL4BQ2.js";import"./chunk-UBFCO3DV.js";import"./chunk-NI7FJV5X.js";import"./chunk-XZIOXVVJ.js";import"./chunk-LFH24RLM.js";import{n as l}from"./chunk-Z5Q7KLA4.js";import"./chunk-X4LNX4BR.js";import"./chunk-4XZ6X7MQ.js";import"./chunk-WLHY3MMA.js";import"./chunk-KGVXGH6H.js";import"./chunk-ARRCN5K3.js";import"./chunk-FTDD7QBB.js";import"./chunk-DB3UIQCU.js";import"./chunk-SBHKMV3P.js";import"./chunk-R4A63S45.js";import"./chunk-ETE32IYO.js";import"./chunk-ONUGDWDK.js";import"./chunk-SG7CQU4O.js";import"./chunk-QHVIRF5H.js";import"./chunk-WZDN6K3C.js";import"./chunk-QGVBCWUY.js";import"./chunk-OJQ73TPF.js";import"./chunk-354SCPDU.js";import"./chunk-OVHPPCBL.js";import"./chunk-IYZFKXJ6.js";import"./chunk-CKJ56T2Q.js";import"./chunk-SNFOAZZQ.js";import"./chunk-F6JAWRPN.js";import"./chunk-UHRSAPGQ.js";import"./chunk-V76GWARL.js";import{a as u,b as f}from"./chunk-N2WTMF3X.js";function a(e){return Array.isArray(e)?e[0]?.spatialReference:e?.spatialReference}function d(e){return e&&(Array.isArray(e)?e.map(d):e.toJSON?e.toJSON():e)}function c(e){return Array.isArray(e)?e.map(t=>y(t)):y(e)}function R(e,t){let n;return Array.isArray(e)?n=e:(n=[],n.push(e),t!=null&&n.push(t)),n}var w;async function h(){return w||(w=g("geometryEngineWorker",{strategy:"distributed"})),w}async function r(e,t){return(await h()).invoke("executeGEOperation",{operation:e,parameters:d(t)})}async function S(e,t){let n=await h();return Promise.all(n.broadcast("executeGEOperation",{operation:e,parameters:d(t)}))}function N(e){return r("extendedSpatialReferenceInfo",[e])}async function D(e,t){return c(await r("clip",[a(e),e,t]))}async function L(e,t){return c(await r("cut",[a(e),e,t]))}function T(e,t){return r("contains",[a(e),e,t])}function V(e,t){return r("crosses",[a(e),e,t])}function v(e,t,n){return r("distance",[a(e),e,t,n])}function E(e,t){return r("equals",[a(e),e,t])}function b(e,t){return r("intersects",[a(e),e,t])}function z(e,t){return r("touches",[a(e),e,t])}function H(e,t){return r("within",[a(e),e,t])}function I(e,t){return r("disjoint",[a(e),e,t])}function P(e,t){return r("overlaps",[a(e),e,t])}function j(e,t,n){return r("relate",[a(e),e,t,n])}function k(e){return r("isSimple",[a(e),e])}async function q(e){return c(await r("simplify",[a(e),e]))}async function B(e,t=!1){return c(await r("convexHull",[a(e),e,t]))}async function C(e,t){return c(await r("difference",[a(e),e,t]))}async function G(e,t){return c(await r("symmetricDifference",[a(e),e,t]))}async function W(e,t){return c(await r("intersect",[a(e),e,t]))}async function F(e,t=null){let n=R(e,t);return c(await r("union",[a(n),n]))}async function K(e,t,n,i,s,p){return c(await r("offset",[a(e),e,t,n,i,s,p]))}async function M(e,t,n,i=!1){let s=[a(e),e,t,n,i];return c(await r("buffer",s))}async function Q(e,t,n,i,s,p){let x=[a(e),e,t,n,i,s,p];return c(await r("geodesicBuffer",x))}async function U(e,t,n=!0){let i=await r("nearestCoordinate",[a(e),e,t,n]);return f(u({},i),{coordinate:l.fromJSON(i.coordinate)})}async function X(e,t){let n=await r("nearestVertex",[a(e),e,t]);return f(u({},n),{coordinate:l.fromJSON(n.coordinate)})}async function Y(e,t,n,i){return(await r("nearestVertices",[a(e),e,t,n,i])).map(s=>f(u({},s),{coordinate:l.fromJSON(s.coordinate)}))}function m(e){return"xmin"in e?e.center:"x"in e?e:e.extent?.center}async function _(e,t,n){if(e==null)throw new o;let i=e.spatialReference;if((n=n??m(e))==null)throw new o;let s=e.constructor.fromJSON(await r("rotate",[i,e,t,n]));return s.spatialReference=i,s}async function $(e,t){if(e==null)throw new o;let n=e.spatialReference;if((t=t??m(e))==null)throw new o;let i=e.constructor.fromJSON(await r("flipHorizontal",[n,e,t]));return i.spatialReference=n,i}async function Z(e,t){if(e==null)throw new o;let n=e.spatialReference;if((t=t??m(e))==null)throw new o;let i=e.constructor.fromJSON(await r("flipVertical",[n,e,t]));return i.spatialReference=n,i}async function ee(e,t,n,i){return c(await r("generalize",[a(e),e,t,n,i]))}async function te(e,t,n){return c(await r("densify",[a(e),e,t,n]))}async function ne(e,t,n,i=0){return c(await r("geodesicDensify",[a(e),e,t,n,i]))}function re(e,t){return r("planarArea",[a(e),e,t])}function ae(e,t){return r("planarLength",[a(e),e,t])}function ie(e,t,n){return r("geodesicArea",[a(e),e,t,n])}function ce(e,t,n){return r("geodesicLength",[a(e),e,t,n])}async function se(e,t){return c(await r("intersectLinesToPoints",[a(e),e,t]))}async function oe(e,t){await S("changeDefaultSpatialReferenceTolerance",[e,t])}async function ue(e){await S("clearDefaultSpatialReferenceTolerance",[e])}var o=class extends Error{constructor(){super("Illegal Argument Exception")}};export{M as buffer,oe as changeDefaultSpatialReferenceTolerance,ue as clearDefaultSpatialReferenceTolerance,D as clip,T as contains,B as convexHull,V as crosses,L as cut,te as densify,C as difference,I as disjoint,v as distance,E as equals,N as extendedSpatialReferenceInfo,$ as flipHorizontal,Z as flipVertical,ee as generalize,ie as geodesicArea,Q as geodesicBuffer,ne as geodesicDensify,ce as geodesicLength,W as intersect,se as intersectLinesToPoints,b as intersects,k as isSimple,U as nearestCoordinate,X as nearestVertex,Y as nearestVertices,K as offset,P as overlaps,re as planarArea,ae as planarLength,j as relate,_ as rotate,q as simplify,G as symmetricDifference,z as touches,F as union,H as within};
