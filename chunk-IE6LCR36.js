import{a as ce,b as M,c as H,d as K,e as be,f as Re,g as vt,h as bt}from"./chunk-SCNTWYD2.js";import{a as xt}from"./chunk-K3Z3MI77.js";import{b as wt,c as St,d as It,e as Tt}from"./chunk-35XAFVAL.js";import{a as Ie,b as j,c as gt,e as N,f as Ft,g as Te,i as O}from"./chunk-C3PAYYXB.js";import{c as pt}from"./chunk-UCYOLKZK.js";import{b as le,c as at,d as we,e as Se,f as rt,g as nt,h as ot,i as lt,j as ut,k as ct,l as ht,n as dt,o as mt,p as ue,q as ft}from"./chunk-WTZT4FKW.js";import{a as ke}from"./chunk-VYI3HIPB.js";import{a as ve,b as _t}from"./chunk-G27DRLGO.js";import{e as Ae}from"./chunk-KRAKR4MK.js";import{a as st}from"./chunk-CDP4MSRO.js";import{m as it}from"./chunk-2NP7F5RO.js";import{a as xe}from"./chunk-CWUY5SXW.js";import{E as et,O as tt,d as Xe,j as Ke}from"./chunk-KD27XIJC.js";import{l as yt}from"./chunk-TPFJWNIU.js";import{a as oe}from"./chunk-NHEQ4TAR.js";import{B as de,C as Ve,D as ee,E as te,F as k}from"./chunk-HP4LYRR4.js";import{b as he}from"./chunk-4G7UTTZJ.js";import{a as _e}from"./chunk-SP2CO3KX.js";import{a as We,e as Ye}from"./chunk-FENRIY2T.js";import{d as Ue,e as Le,i as $e,n as Fe,o as Je}from"./chunk-B3FO6PT7.js";import{a as He,d as ge}from"./chunk-LXFQWIWE.js";import{B as W,ha as ne,m as Q}from"./chunk-KGVXGH6H.js";import{f as je}from"./chunk-SG7CQU4O.js";import{b as Ge,d as ye,v as Ze,w as z}from"./chunk-CKJ56T2Q.js";import{b as J,t as V}from"./chunk-UHRSAPGQ.js";import{n as Ne,o as Oe}from"./chunk-V76GWARL.js";import{a as R,b as B,c as re}from"./chunk-N2WTMF3X.js";var At=new ke(50,500),ie="unsupported-query",Vt=" as ",Ee=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),ze=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),Zt=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...Ee,...ze]);function Be(u,e,t={}){let i=D(e,u);if(!i){let a=At.getError(e,u);throw new V(ie,"invalid SQL expression",{expression:e,error:a})}let s=t.expressionName||"expression";if(t.validateStandardized&&!i.isStandardized)throw new V(ie,`${s} is not standard`,{expression:e});if(t.validateAggregate&&!i.isAggregate)throw new V(ie,`${s} does not contain a valid aggregate function`,{expression:e});return i.fieldNames}function Et(u,e,t,i){if(!t)return!0;let s="where clause";return C(u,e,Be(u,t,{validateStandardized:!0,expressionName:s}),{expressionName:s,query:i}),!0}function zt(u,e,t,i,s){if(!t)return!0;let a="having clause",r=Be(u,t,{validateAggregate:!0,expressionName:a});if(C(u,e,r,{expressionName:a,query:s}),!D(t,u)?.getExpressions().every(l=>{let{aggregateType:c,field:h}=l,d=u.get(h)?.name;return i.some(f=>{let{onStatisticField:y,statisticType:m}=f;return u.get(y)?.name===d&&m.toLowerCase().trim()===c})}))throw new V(ie,"expressions in having clause should also exist in outStatistics",{having:t});return!0}function D(u,e){return u?At.get(u,e):null}function Qe(u){return/\((.*?)\)/.test(u)?u:u.split(Vt)[0]}function Bt(u){return u.split(Vt)[1]}function C(u,e,t,i={}){let s=new Map;if(jt(s,u,e,i.allowedFieldTypes??Zt,t),s.size){let a=i.expressionName??"expression";throw new V(ie,`${a} contains invalid or missing fields`,{errors:Array.from(s.values()),query:i.query})}}function jt(u,e,t,i,s){let a=s.includes("*")?[...t,...s.filter(r=>r!=="*")]:s;for(let r of a)if(e.get(r))Rt(u,e,t,i,r);else try{let n=Be(e,Qe(r),{validateStandardized:!0});for(let o of n)Rt(u,e,t,i,o)}catch(n){u.set(r,{type:"expression-error",expression:r,error:n})}}function Rt(u,e,t,i,s){let a=e.get(s);a?t.has(a.name)?i!=="all"&&i?.has(a.type)===!1&&u.set(s,{type:"invalid-type",fieldName:a.name,fieldType:xe.fromJSON(a.type),allowedFieldTypes:Array.from(i,r=>xe.fromJSON(r))}):u.set(s,{type:"missing-field",fieldName:a.name}):u.set(s,{type:"invalid-field",fieldName:s})}var Ht=5,me=class{constructor(){this._storage=new Map,this._purgeInterval=Ht,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;let e=1e3*this._purgeInterval,t=performance.now()-e;for(let[i,s]of this._storage){if(!(s.time<t))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,e)));this._storage.delete(i)}}}destroy(){this._storage?.clear(),this._storage=null,clearTimeout(this._timer)}put(e,t){this._storage?.set(e,new De(t)),this._scheduleSweep()}get(e){let t=this._storage?.get(e);if(t)return this._storage?.delete(e),t.time=performance.now(),this._storage?.set(e,t),t.items}clear(){this._storage?.clear()}_scheduleSweep(){this._storage&&(this._timer??=setTimeout(this._sweep,1e3*this._purgeInterval))}get test(){}},kt=0,De=class{constructor(e){this.items=e,this.time=performance.now(),this.id=kt++}};var G=class{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=t;let s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let a=0;for(let r of s){let n=Qe(r),o=this.fieldsIndex.get(n),l=o?null:D(n,i),c=o?o.name:Bt(r)||"FIELD_EXP_"+a++;this._fieldDataCache.set(r,{alias:c,clause:l})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){let t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){let s=i?i.name:t,a=null;return this._fieldDataCache.has(s)?a=this._fieldDataCache.get(s)?.clause:i||(a=D(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:a})),i?this.featureAdapter.getAttribute(e,s):a?.calculateValue(e,this.featureAdapter)}getDataValues(e,t,i=!0){let s=t.normalizationType,a=t.normalizationTotal,r=this.fieldsIndex.get(t.field),n=ee(r)||te(r),o=k(r);return e.map(l=>{let c=t.field&&this.getFieldValue(l,t.field,this.fieldsIndex.get(t.field));if(t.field2?(c=`${le(c)}${t.fieldDelimiter}${le(this.getFieldValue(l,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(c=`${c}${t.fieldDelimiter}${le(this.getFieldValue(l,t.field3,this.fieldsIndex.get(t.field3)))}`)):typeof c=="string"&&i&&(n?c=c?new Date(c).getTime():null:o&&(c=c?pt(c):null)),s&&Number.isFinite(c)){let h=s==="field"&&t.normalizationField?this.getFieldValue(l,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;c=ct(c,s,h,a)}return c})}async getExpressionValues(e,t,i,s,a){let{arcadeUtils:r}=await he(),n=r.hasGeometryOperations(t);n&&await r.enableGeometryOperations();let o=r.createFunction(t),l=r.getViewInfo(i),c={fields:this.fieldsIndex.fields};return e.map(h=>{let d={attributes:this.featureAdapter.getAttributes(h),layer:c,geometry:n?B(R({},M(s.geometryType,s.hasZ,s.hasM,this.featureAdapter.getGeometry(h))),{spatialReference:i?.spatialReference}):null},f=r.createExecContext(d,l,a);return r.executeFunction(o,f)})}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:D(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testFeature(e,this.featureAdapter)??!1}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:D(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testSet(e,this.featureAdapter)??!1}_processAttributesForOutFields(e){let t=this.outFields;if(!t?.length)return this.featureAdapter.getAttributes(e);let i={};for(let s of t){let{alias:a,clause:r}=this._fieldDataCache.get(s);i[a]=r?r.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,a)}return i}_processAttributesForDistinctValues(e){if(e==null||!this.returnDistinctValues)return e;let t=this.outFields,i=[];if(t)for(let r of t){let{alias:n}=this._fieldDataCache.get(r);i.push(e[n])}else for(let r in e)i.push(e[r]);let s=`${(t||["*"]).join(",")}=${i.join(",")}`,a=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++a),a>1?null:e}};var Y="bin",A=class{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){let e=new G(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);let{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query;if(!t?.length)return 1;let r=new Map,n=new Map,o=new Set;for(let l of s){let{statisticType:c}=l,h=c!=="exceedslimit"?l.onStatisticField:void 0;if(!n.has(h)){let f=[];for(let y of t){let m=this._getAttributeValues(e,y,this.items,r);f.push(m)}n.set(h,this._calculateUniqueValues(f,this.items,e.returnDistinctValues))}let d=n.get(h);for(let f in d){let{data:y,items:m}=d[f],p=y.join(",");i&&!e.validateItems(m,i)||o.add(p)}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){let t=this.query.geometry;W(this.query.outSR)&&!Q(t.spatialReference,this.query.outSR)?e.queryGeometry=H(R({spatialReference:this.query.outSR},j(t,t.spatialReference,this.query.outSR))):e.queryGeometry=H(R({spatialReference:this.query.outSR},t))}return e}createSnappingResponse(e,t){let i=this.featureAdapter,s=Qt(this.hasZ,this.hasM),{point:a,mode:r}=e,n=typeof e.distance=="number"?e.distance:e.distance.x,o=typeof e.distance=="number"?e.distance:e.distance.y,l={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this.geometryType==="esriGeometryPolyline"||this.geometryType==="esriGeometryPoint",d=this._getPointCreator(r,this.spatialReference,t),f=new fe(null,0),y=new fe(null,0),m={x:0,y:0,z:0};for(let p of this.items){let _=i.getGeometry(p);if(_==null)continue;let{coords:T}=_,S=_.isPoint?Lt:_.lengths;if(f.coords=T,y.coords=T,e.returnEdge){let g=0;for(let x=0;x<S.length;x++){let w=S[x],F=g;for(let I=0;I<w;I++,g+=s){if(!c&&I===w-1)continue;let b=f;b.coordsIndex=g;let v=y;v.coordsIndex=I===w-1?F:g+s;let q=m;if(!Ut(m,a,b,v))continue;let Z=(a.x-q.x)/n,E=(a.y-q.y)/o,L=Z*Z+E*E;L<=1&&l.candidates.push(_t(i.getObjectId(p),d(q),Math.sqrt(L),d(b),d(v)))}}}if(e.vertexMode==="all"){let g=0;for(let x=0;x<S.length;x++){let w=S[x],F=g,I=y;I.coordsIndex=F;for(let b=0;b<w;b++,g+=s){let v=f;if(v.coordsIndex=g,c&&b===w-1&&v.x===I.x&&v.y===I.y)continue;let q=(a.x-v.x)/n,Z=(a.y-v.y)/o,E=q*q+Z*Z;E<=1&&l.candidates.push(ve(i.getObjectId(p),d(v),Math.sqrt(E)))}}}else if(h&&e.vertexMode==="ends"){let g=0,x=[];for(let w=0;w<S.length;w++){x.push(g);let F=S[w];g+=F*s,!c&&F>1&&x.push(g-s)}for(let w of x){let F=f;F.coordsIndex=w;let I=(a.x-F.x)/n,b=(a.y-F.y)/o,v=I*I+b*b;v<=1&&l.candidates.push(ve(i.getObjectId(p),d(F),Math.sqrt(v)))}}}return l.candidates.sort((p,_)=>p.distance-_.distance),l}_getPointCreator(e,t,i){let s=i==null||Q(t,i)?n=>n:n=>j(n,t,i),{hasZ:a}=this,r=0;return e==="3d"?a?({x:n,y:o,z:l})=>s({x:n,y:o,z:l}):({x:n,y:o})=>s({x:n,y:o,z:r}):({x:n,y:o})=>s({x:n,y:o})}async createSummaryStatisticsResponse(e){let{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:o,scale:l,timeZone:c,outStatisticTypes:h}=e,d=this.fieldsIndex.get(t),f=Ve(d)||ee(d)||te(d),y=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:l,timeZone:c},this.items),m=at({normalizationType:a,normalizationField:s,minValue:n,maxValue:o}),p={value:.5,fieldType:d?.type},_=de(d)?we({values:y,supportsNullCount:m,percentileParams:p,outStatisticTypes:h}):Se({values:y,minValue:n,maxValue:o,useSampleStdDev:!a,supportsNullCount:m,percentileParams:p,outStatisticTypes:h});return ot(_,h,f)}async createUniqueValuesResponse(e){let{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:r,timeZone:n}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:r,timeZone:n},this.items,!1),l=lt(o);return ut(l,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){let{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:c,numClasses:h,scale:d,timeZone:f}=e,y=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:d,timeZone:f},this.items),m=ht(y,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:c,numClasses:h});return dt(m,n)}async createHistogramResponse(e){let{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:c,numBins:h,scale:d,timeZone:f}=e,y=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:d,timeZone:f},this.items);return mt(y,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:c,numBins:h})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(let s of t.slice().reverse()){let a=s.split(" "),r=a[0],n=this.fieldsIndex.get(r),o=!!a[1]&&a[1].toLowerCase()==="desc",l=nt(n?.type,o);e.sort((c,h)=>{let d=i(c,r,n),f=i(h,r,n);return l(d,f)})}}_createFeatureQueryResponse(e){let{items:t,geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:n}=this,{outFields:o,outSR:l,quantizationParameters:c,resultRecordCount:h,resultOffset:d,returnZ:f,returnM:y}=e,m=h!=null&&t.length>(d||0)+h,p=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map(_=>this.fieldsIndex.get(_)));return{exceededTransferLimit:m,features:this._createFeatures(e,t),fields:p,geometryType:i,hasM:s&&y,hasZ:a&&f,objectIdFieldName:r,spatialReference:H(l||n),transform:c&&_e(c)||null}}_createFeatures(e,t){let i=new G(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:n,returnGeometry:o,returnCentroid:l,maxAllowableOffset:c,resultOffset:h,resultRecordCount:d,returnZ:f=!1,returnM:y=!1}=e,m=a&&f,p=s&&y,_=[],T=0,S=[...t];if(this._sortFeatures(S,r,(x,w,F)=>i.getFieldValue(x,w,F)),this.geometryType&&(o||l)){let x=_e(n)??void 0,w=this.geometryType==="esriGeometryPolygon"||this.geometryType==="esriGeometryPolyline";if(o&&!l)for(let F of S){let I=this.featureAdapter.getGeometry(F),b={attributes:i.getAttributes(F),geometry:M(this.geometryType,this.hasZ,this.hasM,I,c,x,m,p)};w&&I&&!b.geometry&&(b.centroid=ce(this,this.featureAdapter.getCentroid(F,this),x)),_[T++]=b}else if(!o&&l)for(let F of S)_[T++]={attributes:i.getAttributes(F),centroid:ce(this,this.featureAdapter.getCentroid(F,this),x)};else for(let F of S)_[T++]={attributes:i.getAttributes(F),centroid:ce(this,this.featureAdapter.getCentroid(F,this),x),geometry:M(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(F),c,x,m,p)}}else for(let x of S){let w=i.getAttributes(x);w&&(_[T++]={attributes:w})}let g=h||0;if(d!=null){let x=g+d;_=_.slice(g,Math.min(_.length,x))}return _}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(let a of this.query.outStatistics??[])if(a.statisticType==="exceedslimit"){t=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,i=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,s=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>t;else if(this.items.length>i)e=!0;else{let a=Qt(this.hasZ,this.hasM),r=this.featureAdapter;e=this.items.reduce((n,o)=>{let l=r.getGeometry(o);return n+(l!=null&&l.coords.length||0)},0)/a>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){let s=[],a=new Map,r=new Map,n=new Map,o=new Map,l=new G(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:h,having:d,orderByFields:f,resultRecordCount:y}=e,m=h?.length,p=!!m,_=p?h[0]:null,T=p&&!this.fieldsIndex.get(_);for(let g of c??[]){let{outStatisticFieldName:x,statisticType:w}=g,F=g,I=w!=="exceedslimit"?g.onStatisticField:void 0,b=w==="percentile_disc"||w==="percentile_cont",v=w==="EnvelopeAggregate"||w==="CentroidAggregate"||w==="ConvexHullAggregate",q=p&&m===1&&(I===_||T)&&w==="count";if(p){if(!n.has(I)){let se=[];for(let pe of h){let ae=this._getAttributeValues(l,pe,t,a);se.push(ae)}n.set(I,this._calculateUniqueValues(se,t,!v&&l.returnDistinctValues))}let E=n.get(I);if(!E)continue;let L=Object.keys(E);for(let se of L){let{count:pe,data:ae,items:qe,itemPositions:Nt}=E[se],Pe=ae.join(",");if(!d||l.validateItems(qe,d)){let $=o.get(Pe)||{attributes:{}};if(v){$.aggregateGeometries||($.aggregateGeometries={});let{aggregateGeometries:P,outStatisticFieldName:X}=await this._getAggregateGeometry(F,qe);$.aggregateGeometries[X]=P}else{let P=null;if(q)P=pe;else{let X=this._getAttributeValues(l,I,t,a),Me=Nt.map(Gt=>X[Gt]);P=b&&"statisticParameters"in F?this._getPercentileValue(F,Me):this._getStatisticValue(F,Me,null,l.returnDistinctValues)}$.attributes[x]=P}let Ot=0;h.forEach((P,X)=>$.attributes[this.fieldsIndex.get(P)?P:"EXPR_"+ ++Ot]=ae[X]),o.set(Pe,$)}}}else if(v){i.aggregateGeometries||(i.aggregateGeometries={});let{aggregateGeometries:E,outStatisticFieldName:L}=await this._getAggregateGeometry(F,t);i.aggregateGeometries[L]=E}else{let E=this._getAttributeValues(l,I,t,a);i.attributes[x]=b&&"statisticParameters"in F?this._getPercentileValue(F,E):this._getStatisticValue(F,E,r,l.returnDistinctValues)}let Z=w!=="min"&&w!=="max"||!de(this.fieldsIndex.get(I))&&!this._isAnyDateField(I)?null:this.fieldsIndex.get(I)?.type;s.push({name:x,alias:x,type:Z||"esriFieldTypeDouble"})}let S=p?Array.from(o.values()):[i];return this._sortFeatures(S,f,(g,x)=>g.attributes[x]),y&&(S.length=Math.min(y,S.length)),{fields:s,features:S}}_isAnyDateField(e){let t=this.fieldsIndex.get(e);return Ve(t)||ee(t)||te(t)||k(t)}async _getAggregateGeometry(e,t){let{convexHull:i,union:s}=await import("./chunk-6SESXOXB.js"),{statisticType:a,outStatisticFieldName:r}=e,{featureAdapter:n,spatialReference:o,geometryType:l,hasZ:c,hasM:h}=this,d=t.map(m=>M(l,c,h,n.getGeometry(m))),f=i(o,d,!0)[0],y={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){let m=f?Je(f):Fe(s(o,d));y.aggregateGeometries=B(R({},m),{spatialReference:o}),y.outStatisticFieldName=r||"extent"}else if(a==="CentroidAggregate"){let m=f?Le(f):Ue(Fe(s(o,d)));y.aggregateGeometries={x:m[0],y:m[1],spatialReference:o},y.outStatisticFieldName=r||"centroid"}else a==="ConvexHullAggregate"&&(y.aggregateGeometries=f,y.outStatisticFieldName=r||"convexHull");return y}_getStatisticValue(e,t,i,s){let{onStatisticField:a,statisticType:r}=e,n=null;return n=i?.has(a)?i.get(a):de(this.fieldsIndex.get(a))||this._isAnyDateField(a)?we({values:t,returnDistinct:s}):Se({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n),n[r==="var"?"variance":r]}_getPercentileValue(e,t){let{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i);return rt(t,{value:r,orderBy:n,fieldType:o?.type,isDiscrete:a==="percentile_disc"})}_getAttributeValues(e,t,i,s){if(s.has(t))return s.get(t);let a=this.fieldsIndex.get(t),r=i.map(n=>e.getFieldValue(n,t,a));return s.set(t,r),r}_calculateUniqueValues(e,t,i){let s={},a=t.length;for(let r=0;r<a;r++){let n=t[r],o=[];for(let c of e)o.push(c[r]);let l=o.join(",");s[l]==null?s[l]={count:1,data:o,items:[n],itemPositions:[r]}:(i||s[l].count++,s[l].items.push(n),s[l].itemPositions.push(r))}return s}async _getDataValues(e,t,i=!0){let s=new G(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:a,scale:r,timeZone:n}=e;return a?s.getExpressionValues(t,a,{viewingMode:"map",scale:r,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},n):s.getDataValues(t,J(e),i)}async _calculateHistogramBins(e,t,i){if(t.min==null&&t.max==null)return[];let s=t.intervals,a=t.min??0,r=t.max??0,n=s.map(([o,l])=>({minValue:o,maxValue:l,count:0,items:[]}));for(let o=0;o<e.length;o++){let l=e[o],c=i[o];if(l!=null&&l>=a&&l<=r){let h=ft(s,l);h>-1&&(n[h].count++,n[h].items.push(c))}}return n}async createQueryBinsResponse(e){let t=e.bin?.splitBy;if(!t)return this._createBinsResponse(e);let{value:i,outAlias:s,valueType:a}=t,r=[],n=[{name:s??i,alias:s??i,type:a??"esriFieldTypeString"},{name:Y,alias:Y,type:"esriFieldTypeInteger"}],o=new G(e,this.featureAdapter,this.fieldsIndex),l=new Map,c=[...this.items];this._sortFeatures(c,[i],(f,y,m)=>o.getFieldValue(f,y,m));let h=this._getAttributeValues(o,i,c,l),d=this._calculateUniqueValues([h],c,o.returnDistinctValues);for(let f in d){let{items:y}=d[f],m=await this._createBinsResponse(e,y);if(r.push(...m.features.map(p=>B(R({},p),{attributes:B(R({},p.attributes),{[s??i]:f})}))),m.fields)for(let p of m.fields)n.some(_=>_.name===p.name)||n.push(p)}return{fields:n,features:r}}async _createBinsResponse(e,t){let i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(wt.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(St.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(It.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(Tt.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){let{field:s,normalizationField:a,numBins:r,normalizationType:n,normalizationTotal:o,start:l,end:c}=e,h=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),d=ue(h,{field:s,normalizationField:a,normalizationType:n,normalizationTotal:o,numBins:r,minValue:O(l,!1),maxValue:O(c,!1)}),f=await this._calculateHistogramBins(h,d,i);return this._createFeaturesFromHistogramBins(f,t)}async _createDateBinsResponse(e,t,i){let{field:s,interval:a,start:r,end:n}=e,o=a.unit,l=o==="quarters"?3*oe.months:oe[o],c=a.value*l/oe.milliseconds,h=await this._getDataValues({field:e.field,timeZone:t.outTimeReference?.ianaTimeZone},i),d=k(this.fieldsIndex.get(s)),f=ue(h,{field:s,classificationMethod:"defined-interval",definedInterval:c,minValue:O(r,d),maxValue:O(n,d)},!0),y=await this._calculateHistogramBins(h,f,i);return this._createFeaturesFromHistogramBins(y,t)}async _createFixedBoundariesBinsResponse(e,t,i){let{field:s}=e,a=await this._getDataValues({field:s,timeZone:t.outTimeReference?.ianaTimeZone},i),r=k(this.fieldsIndex.get(s)),n=e.boundaries.map(h=>O(h,r)).sort((h,d)=>h-d),o=[];for(let h=0;h<n.length-1;h++)o.push([n[h],n[h+1]]);let l={intervals:o,min:n.at(0),max:n.at(-1)},c=await this._calculateHistogramBins(a,l,i);return this._createFeaturesFromHistogramBins(c,t)}async _createFixedIntervalBinsResponse(e,t,i){let{field:s,interval:a,start:r,end:n}=e,o=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),l=k(this.fieldsIndex.get(s)),c=ue(o,{field:s,classificationMethod:"defined-interval",definedInterval:a,minValue:O(r,l),maxValue:O(n,l)},!0),h=await this._calculateHistogramBins(o,c,i);return this._createFeaturesFromHistogramBins(h,t)}async _createFeaturesFromHistogramBins(e,t){let{upperBoundaryAlias:i,lowerBoundaryAlias:s}=t,a=s||"lowerBoundary",r=i||"upperBoundary",n=[],o=[{name:a,alias:a,type:"esriFieldTypeDouble"},{name:r,alias:r,type:"esriFieldTypeDouble"}],l=t.bin?.stackBy?.value,c=t.bin?.stackBy?.outAlias;l&&o.push({name:Y,alias:Y,type:"esriFieldTypeInteger"},{name:c??l,alias:c??l,type:"esriFieldTypeString"});let h=0;for(let d of e){let{minValue:f,maxValue:y,items:m}=d,p={attributes:{}},_;if(p.attributes[a]=f,p.attributes[r]=y,l?(_=await this._createStatisticsQueryResponse(B(R({},t),{groupByFieldsForStatistics:[l],orderByFields:[l]}),m),p.attributes[Y]=++h,t.bin.jsonStyle==="flat"?n.push(..._.features.map(x=>{var w=x,{attributes:F}=w,I=F,{EXPR_1:T}=I,S=re(I,["EXPR_1"]),g=re(w,["attributes"]);return B(R({},g),{attributes:R(c??T?B(R({},S),{[c??T]:T}):R({},S),p.attributes)})})):(p.stackedAttributes=_.features.map(g=>{var{attributes:x}=g,w=x,{EXPR_1:T}=w,S=re(w,["EXPR_1"]);return c??T?B(R({},S),{[c??T]:T}):S}),n.push(p))):(t.bin?.splitBy&&(p.attributes[Y]=++h),_=await this._createStatisticsQueryResponse(t,m,p),n.push(p)),_.fields)for(let T of _.fields)o.some(S=>S.name===T.name)||o.push(T)}return t.binOrder==="desc"&&n.reverse(),{fields:o,features:n}}};function Ut(u,e,t,i){let s=i.x-t.x,a=i.y-t.y,r=e.x-t.x,n=e.y-t.y,o=s*s+a*a;if(o===0)return!1;let l=r*s+n*a,c=Math.min(1,Math.max(0,l/o));return u.x=t.x+s*c,u.y=t.y+a*c,!0}function Qt(u,e){return u?e?4:3:e?3:2}var fe=class{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}},Lt=[1];var U="unsupported-query";async function Dt(u,e){let t=u.bin;if(!t.onField&&!t.onExpression?.value||t.type==="autoIntervalBin"&&t.parameters.numberOfBins==null||t.type==="dateBin"&&(t.parameters.number==null||t.parameters.unit==null)||t.type==="fixedBoundariesBin"&&t.parameters.boundaries==null||t.type==="fixedIntervalBin"&&t.parameters.interval==null)throw new V(U,"Unsupported query options",{query:u});return Ce(u,e)}async function Ce(u,{fieldsIndex:e,geometryType:t,spatialReference:i,availableFields:s}){if(u.geometryPrecision!=null||u.multipatchOption&&u.multipatchOption!=="xyFootprint"||u.pixelSize||u.relationParam||u.text)throw new V(U,"Unsupported query options",{query:u});return Ct(e,s,u),Jt(e,s,u),Promise.all([be(u,t,i),Ie(i,u.outSR)]).then(()=>u)}function Ct(u,e,t){let{outFields:i,orderByFields:s,returnDistinctValues:a,outStatistics:r}=t,n=r?r.map(o=>o.outStatisticFieldName&&o.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(s&&s.length>0){let o=" asc",l=" desc",c=s.map(h=>{let d=h.toLowerCase();return d.includes(o)?d.split(o)[0]:d.includes(l)?d.split(l)[0]:h}).filter(h=>!n.includes(h));C(u,e,c,{expressionName:"orderByFields",query:t})}if(i&&i.length>0)C(u,e,i,{expressionName:"outFields",query:t,allowedFieldTypes:"all"});else if(a)throw new V(U,"outFields should be specified for returnDistinctValues",{query:t});Et(u,e,t.where,t)}var $t=new Set([...Ee,...ze]);function Jt(u,e,t){let{outStatistics:i,groupByFieldsForStatistics:s,having:a}=t,r=s?.length,n=i?.length;if(a){if(!r||!n)throw new V(U,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});zt(u,e,a,i,t)}if(n){if(!Yt(i))return;let o=i.map(l=>l.onStatisticField).filter(Boolean);C(u,e,o,{expressionName:"onStatisticFields",query:t}),r&&C(u,e,s,{expressionName:"groupByFieldsForStatistics",query:t});for(let l of i){let{onStatisticField:c,statisticType:h}=l;if((h==="percentile_disc"||h==="percentile_cont")&&"statisticParameters"in l){let{statisticParameters:d}=l;if(!d)throw new V(U,"statisticParameters should be set for percentile type",{definition:l,query:t})}else u.get(c)&&h!=="count"&&h!=="min"&&h!=="max"&&C(u,e,[c],{expressionName:`outStatistics with '${h}' statistic type`,allowedFieldTypes:$t,query:t})}}}async function qt(u,e,{fieldsIndex:t,geometryType:i,spatialReference:s,availableFields:a}){if(u.geometryPrecision!=null||u.multipatchOption||u.pixelSize||u.relationParam||u.text||u.outStatistics||u.groupByFieldsForStatistics||u.having||u.orderByFields)throw new V(U,"Unsupported query options",{query:u});return Ct(t,a,u),Promise.all([Wt(t,a,e,u),be(u,i,s),Ie(s,u.outSR)]).then(()=>u)}async function Wt(u,e,t,i){let s=[];if(t.valueExpression){let{arcadeUtils:a}=await he();s=a.extractFieldNames(t.valueExpression)}if(t.field&&s.push(t.field),t.field2&&s.push(t.field2),t.field3&&s.push(t.field3),t.normalizationField&&s.push(t.normalizationField),!s.length&&!t.valueExpression)throw new V(U,"field or valueExpression is required",{params:t});C(u,e,s,{expressionName:"statistics",query:i})}function Yt(u){return u!=null&&u.every(e=>e.statisticType!=="exceedslimit")}var Xt="unsupported-query";var Pt=class{constructor(e){this._changeHandle=null,this.capabilities={query:xt},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new me,this.timeInfo=e.timeInfo,this._changeHandle=this.featureStore.events.on("changed",()=>this._clearCache()),this.fieldsIndex=je.isSerializable(e.fieldsIndex)?e.fieldsIndex:st.fromJSON(e.fieldsIndex),!e.availableFields||e.availableFields.length===1&&e.availableFields[0]==="*"?this.availableFields=new Set(this.fieldsIndex.fields.map(t=>t.name)):this.availableFields=new Set(e.availableFields.map(t=>this.fieldsIndex.get(t)?.name).filter(t=>t!=null)),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._changeHandle=ye(this._changeHandle),this._frameTask=ye(this._frameTask),this._clearCache(),Ge(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,t){let i=z(t);try{return await(await this._executeQuery(e,{},i)).createQueryResponse()}catch(s){if(s!==N)throw s;return new A([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){let i=z(t);try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},i)).createQueryResponseForCount()}catch(s){if(s!==N)throw s;return 0}}async executeQueryForExtent(e,t){let i=z(t),s=e.outSR;try{let a=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),r=a.size;return r?{count:r,extent:await this._getBounds(a.items,a.spatialReference,s||this.spatialReference)}:{count:0,extent:null}}catch(a){if(a===N)return{count:0,extent:null};throw a}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then(i=>Array.from(i))}async executeQueryForIdSet(e,t){let i=z(t);try{let s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),a=s.items,r=new Set;return await this.reschedule(()=>{for(let n of a)r.add(s.featureAdapter.getObjectId(n))},i),r}catch(s){if(s===N)return new Set;throw s}}async executeQueryForLatestObservations(e,t){let i=z(t);if(!this.timeInfo?.trackIdField)throw new V(Xt,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{let s=await this._executeQuery(e,{},i);return await this.reschedule(()=>this._filterLatest(s),i),await s.createQueryResponse()}catch(s){if(s!==N)throw s;return new A([],e,this).createQueryResponse()}}async executeAttributeBinsQuery(e,t){let i=z(t),s;e=J(e);try{e=await this.schedule(()=>Ft(e,this.definitionExpression,this.spatialReference),i),e=await this.reschedule(()=>Dt(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),i);let a=await this.reschedule(()=>this._executeSceneFilterQuery(e,i),i);s=await this.reschedule(()=>this._executeGeometryQuery(e,a,i),i),await this.reschedule(()=>this._executeAggregateIdsQuery(s),i),await this.reschedule(()=>this.executeObjectIdsQuery(s),i),await this.reschedule(()=>this.executeTimeQuery(s),i),await this.reschedule(()=>this.executeAttributesQuery(s),i)}catch(a){if(a!==N)throw a;s=new A([],e,this)}return s.createQueryBinsResponse(e)}async executeQueryForSummaryStatistics(e={},t,i){let s=z(i),{field:a,normalizationField:r,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:n},s)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){let s=z(i),{field:a,field2:r,field3:n,valueExpression:o}=t;return(await this._executeQueryForStatistics(e,{field:a,field2:r,field3:n,valueExpression:o},s)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){let s=z(i),{field:a,normalizationField:r,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:n},s)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){let s=z(i),{field:a,normalizationField:r,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:n},s)).createHistogramResponse(t)}async fetchRecomputedExtents(e){let t=z(e);this._timeExtentPromise||=vt(this.timeInfo,this.featureStore);let[i,s]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return Ze(t),{fullExtent:i,timeExtent:s}}async _getBounds(e,t,i){let s=et(Xe(),tt);await this.featureStore.forEachBounds(e,n=>Ke(s,n));let a={xmin:s[0],ymin:s[1],xmax:s[3],ymax:s[4],spatialReference:H(this.spatialReference)};this.hasZ&&isFinite(s[2])&&isFinite(s[5])&&(a.zmin=s[2],a.zmax=s[5],a.hasZ=!0);let r=j(a,t,i);if(r.spatialReference=H(i),r.xmax-r.xmin==0){let n=ne(r.spatialReference);r.xmin-=n,r.xmax+=n}if(r.ymax-r.ymin==0){let n=ne(r.spatialReference);r.ymin-=n,r.ymax+=n}if(this.hasZ&&r.zmin!=null&&r.zmax!=null&&r.zmax-r.zmin==0){let n=ne(r.spatialReference);r.zmin-=n,r.zmax+=n}return r}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference)),this._fullExtentPromise}async schedule(e,t){return this._frameTask?.schedule(e,t)??e(Ae)}async reschedule(e,t){return this._frameTask?.reschedule(e,t)??e(Ae)}async _getAllFeaturesQueryEngineResult(e){return new A(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){let i=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach(s=>i.push(s)))().then(()=>i)}let e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=J(e),e=await this.schedule(()=>Te(e,this.definitionExpression,this.spatialReference),i),e=await this.reschedule(()=>Ce(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),i),e=R(R({},e),t);let s=await this.reschedule(()=>this._executeSceneFilterQuery(e,i),i),a=await this.reschedule(()=>this._executeGeometryQuery(e,s,i),i);return await this.reschedule(()=>this._executeAggregateIdsQuery(a),i),await this.reschedule(()=>this.executeObjectIdsQuery(a),i),await this.reschedule(()=>this.executeTimeQuery(a),i),await this.reschedule(()=>this.executeAttributesQuery(a),i),a}async _executeSceneFilterQuery(e,t){if(e.sceneFilter==null)return null;let{outSR:i,returnGeometry:s,returnCentroid:a}=e,r=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,o=r==null||Q(r,n.spatialReference)?n:j(n,r);if(!o)return null;let l=s||a,c=W(i)&&!Q(this.spatialReference,i)&&l?async m=>this._project(m,i):m=>m,h=this.featureAdapter,d=await this.reschedule(()=>this.searchFeatures(Mt(o)),t);if(e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;let m=new Set;for(let T of d)m.add(h.getObjectId(T));let p=await this.reschedule(()=>this._getAllFeatures(),t),_=await this.reschedule(async()=>{let T=await K("esriSpatialRelDisjoint",o,this.geometryType,this.hasZ,this.hasM),S=x=>!m.has(h.getObjectId(x))||T(h.getGeometry(x)),g=await this.runSpatialFilter(p,S,t);return new A(g,e,this)},t);return c(_)}if(!d.length)return new A([],e,this);if(this._canExecuteSinglePass(o,e))return c(new A(d,e,this));let f=await K("esriSpatialRelContains",o,this.geometryType,this.hasZ,this.hasM),y=await this.runSpatialFilter(d,m=>f(h.getGeometry(m)),t);return c(new A(y,e,this))}async _executeGeometryQuery(e,t,i){if(t!=null&&t.items.length===0)return t;let{geometry:s,outSR:a,returnGeometry:r,returnCentroid:n}=e,o=t?null:this._getCacheKey(e),l=o?this._cache.get(o):null;if(l)return new A(l,e,this);let c=W(a)&&!Q(this.spatialReference,a),h=r||n,d=async g=>(c&&h&&await this._project(g,a),o&&this._cache.put(o,g.items),g),f=this.featureStore.featureSpatialReference,y=!s||f==null||Q(f,s.spatialReference)?s:j(s,f);if(!y)return d(t??await this._getAllFeaturesQueryEngineResult(e));let m=this.featureAdapter,p=await this.reschedule(()=>this.searchFeatures(Mt(s)),i),_=e.spatialRel??"esriSpatialRelIntersects";if(_==="esriSpatialRelDisjoint"){if(!p.length)return d(t??await this._getAllFeaturesQueryEngineResult(e));let g=new Set;for(let F of p)g.add(m.getObjectId(F));let x=t!=null?t.items:await this.reschedule(()=>this._getAllFeatures(),i),w=await this.reschedule(async()=>{let F=await K(_,y,this.geometryType,this.hasZ,this.hasM),I=v=>!g.has(m.getObjectId(v))||F(m.getGeometry(v)),b=await this.runSpatialFilter(x,I,i);return new A(b,e,this)},i);return d(w)}if(t!=null){let g=new Ne;p=p.filter(x=>Oe(t.items,x,t.items.length,g)>=0)}if(!p.length){let g=new A([],e,this);return o&&this._cache.put(o,g.items),g}if(this._canExecuteSinglePass(y,e))return d(new A(p,e,this));let T=await K(_,y,this.geometryType,this.hasZ,this.hasM),S=await this.runSpatialFilter(p,g=>T(m.getGeometry(g)),i);return d(new A(S,e,this))}_executeAggregateIdsQuery(e){if(e.items.length===0||!e.query.aggregateIds?.length||this.aggregateAdapter==null)return;let t=new Set;for(let s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach(a=>t.add(a));let i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}executeObjectIdsQuery(e){if(e.items.length===0||!e.query.objectIds?.length)return;let t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}executeTimeQuery(e){if(e.items.length===0)return;let t=bt(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}executeAttributesQuery(e){if(e.items.length===0)return;let t=D(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(i=>t.testFeature(i,this.featureAdapter))}}async runSpatialFilter(e,t,i){if(!t)return e;if(this._frameTask==null)return e.filter(n=>t(n));let s=0,a=new Array,r=async n=>{for(;s<e.length;){let o=e[s++];t(o)&&(a.push(o),n.madeProgress()),n.done&&await this.reschedule(l=>r(l),i)}};return this.reschedule(n=>r(n),i).then(()=>a)}_filterLatest(e){let{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,a=s||i,r=new Map,n=this.featureAdapter.getAttribute;for(let o of e.items){let l=n(o,t),c=n(o,a),h=r.get(l);(!h||c>n(h,a))&&r.set(l,o)}e.items=Array.from(r.values())}_getCacheKey(e){let{geometry:t,spatialRel:i,returnGeometry:s,returnCentroid:a,outSR:r,resultType:n,cacheHint:o}=e;if(n!=="tile"&&!o)return null;let l=s||a;return W(r)&&!Q(this.spatialReference,r)&&l?JSON.stringify([t,i,r]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){let{spatialRel:i}=t;return Re(e)&&(i==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"))}async _project(e,t){if(!t||Q(this.spatialReference,t))return e;let i=this.featureAdapter,s;try{let r=await this._getFullExtent();s=yt(this.spatialReference,t,r)}catch{}let a=await gt(e.items.map(r=>M(this.geometryType,this.hasZ,this.hasM,i.getGeometry(r))),this.spatialReference,t,s);return e.items=a.map((r,n)=>i.cloneWithGeometry(e.items[n],it(r,this.hasZ,this.hasM))),e}async searchFeatures(e){let t=new Set;await Promise.all(e.map(s=>this.featureStore.forEachInBounds(s,a=>t.add(a))));let i=Array.from(t.values());return t.clear(),i}async _executeQueryForStatistics(e,t,i){e=J(e);try{e=await this.schedule(()=>Te(e,this.definitionExpression,this.spatialReference),i),e=await this.reschedule(()=>qt(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),i);let s=await this.reschedule(()=>this._executeSceneFilterQuery(e,i),i),a=await this.reschedule(()=>this._executeGeometryQuery(e,s,i),i);return await this.reschedule(()=>this._executeAggregateIdsQuery(a),i),await this.reschedule(()=>this.executeObjectIdsQuery(a),i),await this.reschedule(()=>this.executeTimeQuery(a),i),await this.reschedule(()=>this.executeAttributesQuery(a),i),a}catch(s){if(s!==N)throw s;return new A([],e,this)}}get test(){}};function Mt(u){if(Re(u)){if(We(u))return[ge(Math.min(u.xmin,u.xmax),Math.min(u.ymin,u.ymax),Math.max(u.xmin,u.xmax),Math.max(u.ymin,u.ymax))];if(Ye(u))return u.rings.map(e=>ge(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[$e(He(),u)]}export{A as a,Ce as b,Pt as c,Mt as d};
