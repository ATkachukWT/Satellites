import{a as U,b as At,c as Bt,d as Ce,e as H,f as G,i as ue,j as q,k as be}from"./chunk-BMYBVFRS.js";import"./chunk-3ZN3HQ7V.js";import{a as Dt}from"./chunk-3VQM2VTO.js";import{a as kt,c as Nt,d as Et}from"./chunk-GN27G772.js";import{a as Fe}from"./chunk-53QT4ZXE.js";import{a as St,l as Pt}from"./chunk-Y4TT5CQV.js";import{c as vt,d as Tt,e as Rt,h as _t,i as Ft,j as Ct,k as Ot,m as Mt}from"./chunk-4PDI5FRK.js";import{b as wt,c as ee}from"./chunk-ITBK54KO.js";import{c as yt,d as xt}from"./chunk-KVIE5PSM.js";import"./chunk-KMLF2ICK.js";import{U as Ie,V as gt,W as Z,a as _e,b as pe,c as it,d as at,e as ot,f as nt,g as lt,h as mt,i as ct,j as pt,k as ut,p as Q,q as W}from"./chunk-IPR4SOKY.js";import{A as ht,B as dt,c as rt,h as K,y as ft}from"./chunk-VKKXXOQY.js";import"./chunk-6FDNNAVT.js";import"./chunk-47CBJZNC.js";import"./chunk-VU5W7W6Y.js";import"./chunk-JAENS3D3.js";import"./chunk-3ATD3H4Q.js";import{a as ce}from"./chunk-WDTJILD4.js";import"./chunk-NNX76JDG.js";import"./chunk-76O2P2CB.js";import{a as Qe}from"./chunk-WKYBGWI5.js";import{b as tt}from"./chunk-4Y623NMU.js";import"./chunk-PTAJ247D.js";import{a as st}from"./chunk-O4MHA7YC.js";import"./chunk-XHEYQWRE.js";import{a as Ze}from"./chunk-R5HXEPJ3.js";import{b as qe}from"./chunk-CJM4TC3F.js";import{c as We}from"./chunk-J5PZXDWN.js";import"./chunk-ME2B26KJ.js";import"./chunk-U7PX7SHO.js";import{a as $e}from"./chunk-DZBH24YT.js";import{a as bt}from"./chunk-7E723FQO.js";import{f as It}from"./chunk-SVJ5AK5B.js";import"./chunk-FXCL7YYQ.js";import"./chunk-BGOXHRAZ.js";import"./chunk-SXNHGK6A.js";import"./chunk-TMZQBNSB.js";import"./chunk-PFSX77NO.js";import"./chunk-ZJWWZWMH.js";import"./chunk-W45QYQK6.js";import"./chunk-I5V562B6.js";import{a as et}from"./chunk-WT3XCHGP.js";import{a as Ve}from"./chunk-CUJB6F5L.js";import{a as Lt}from"./chunk-5NHJFBCW.js";import{a as we}from"./chunk-WPZN772I.js";import"./chunk-K27EVVBH.js";import"./chunk-JGU5JAYW.js";import"./chunk-LCMPSAU3.js";import"./chunk-CRJDOM7J.js";import"./chunk-BCFGKQ2N.js";import"./chunk-YQGS4EZO.js";import"./chunk-3REMXE4W.js";import{p as Ke}from"./chunk-4ABKPPKG.js";import"./chunk-PMVQ5DJK.js";import"./chunk-I4Q2S2XA.js";import"./chunk-V774RJYN.js";import"./chunk-L2WNUKLP.js";import"./chunk-XITT4JU2.js";import"./chunk-ZBX6HJOS.js";import"./chunk-BSMAMABT.js";import"./chunk-LYNAYPL3.js";import"./chunk-ULANM5YP.js";import"./chunk-77L5NP7A.js";import"./chunk-2G3SBK6Q.js";import"./chunk-VOB6IBIW.js";import"./chunk-63B3IOWG.js";import{a as Xe}from"./chunk-KAMRW6HF.js";import"./chunk-YW3L7OMP.js";import{b as me}from"./chunk-6YRWGF73.js";import"./chunk-V2JYXY4D.js";import"./chunk-LAVV77UH.js";import"./chunk-VTGWQ7AP.js";import"./chunk-USMAJP2P.js";import"./chunk-PHNFWHVF.js";import{e as Re}from"./chunk-W26XKMAT.js";import"./chunk-NQWYPF77.js";import"./chunk-6KRFVLII.js";import"./chunk-TOH4K6HW.js";import"./chunk-UP6FLASM.js";import"./chunk-DGBDFGKO.js";import"./chunk-44S2QQS2.js";import{a as Ye}from"./chunk-JTDXB5TK.js";import"./chunk-XCIPBOI4.js";import"./chunk-CWUY5SXW.js";import"./chunk-KD27XIJC.js";import"./chunk-TPFJWNIU.js";import"./chunk-P25RU3X5.js";import"./chunk-XRRQM4E2.js";import"./chunk-GWBRHLNH.js";import"./chunk-NHEQ4TAR.js";import"./chunk-RZF6KTKU.js";import"./chunk-HP4LYRR4.js";import"./chunk-AFC2H4Q3.js";import"./chunk-OLOKUDVI.js";import"./chunk-4G7UTTZJ.js";import"./chunk-ZTOZWLEE.js";import"./chunk-RJWOVI3M.js";import"./chunk-NRBJLISB.js";import"./chunk-PTZYZULI.js";import"./chunk-NMLYCCKN.js";import"./chunk-RSDQHAJX.js";import"./chunk-BOVYXYHK.js";import"./chunk-FENRIY2T.js";import"./chunk-5HJY3X5Y.js";import"./chunk-6RZAM42M.js";import"./chunk-HX2VGIR2.js";import"./chunk-64QN2VGD.js";import"./chunk-JGEVVXD4.js";import"./chunk-B3FO6PT7.js";import"./chunk-C4UMJHQC.js";import"./chunk-BCREO4Q5.js";import"./chunk-LXFQWIWE.js";import"./chunk-QT6UNBJP.js";import"./chunk-V2GNNIXD.js";import"./chunk-NSYL2RQJ.js";import{a as Ge}from"./chunk-MWSXMSWY.js";import"./chunk-JRCKELO6.js";import"./chunk-ZVCMULXF.js";import"./chunk-KJULKTB5.js";import"./chunk-LACL4BQ2.js";import"./chunk-YR2HD3ZC.js";import"./chunk-GJASVPF6.js";import"./chunk-UBFCO3DV.js";import"./chunk-NMRTZBDM.js";import"./chunk-NI7FJV5X.js";import"./chunk-BUSG3ZOF.js";import"./chunk-XZIOXVVJ.js";import"./chunk-5RAXVJQI.js";import"./chunk-EXJYW3PC.js";import"./chunk-SXQPBCOX.js";import{m as L}from"./chunk-LFH24RLM.js";import{n as j}from"./chunk-Z5Q7KLA4.js";import"./chunk-X4LNX4BR.js";import{a as P}from"./chunk-4XZ6X7MQ.js";import"./chunk-WLHY3MMA.js";import{s as je}from"./chunk-KGVXGH6H.js";import"./chunk-ARRCN5K3.js";import"./chunk-LXQPIAN7.js";import{b as He}from"./chunk-FTDD7QBB.js";import"./chunk-DB3UIQCU.js";import"./chunk-SBHKMV3P.js";import"./chunk-R4A63S45.js";import"./chunk-ETE32IYO.js";import{h as Ue}from"./chunk-ONUGDWDK.js";import"./chunk-SG7CQU4O.js";import{H as R}from"./chunk-QHVIRF5H.js";import{I as D,o as ze}from"./chunk-WZDN6K3C.js";import{a as v}from"./chunk-QGVBCWUY.js";import"./chunk-OJQ73TPF.js";import"./chunk-354SCPDU.js";import"./chunk-OVHPPCBL.js";import"./chunk-IYZFKXJ6.js";import{G as xe,O as Je,a as Be,u as De,y as Le}from"./chunk-CKJ56T2Q.js";import"./chunk-SNFOAZZQ.js";import"./chunk-F6JAWRPN.js";import{r as le,t as T}from"./chunk-UHRSAPGQ.js";import{a as Ae,w as ne}from"./chunk-V76GWARL.js";import{a as A,b as z}from"./chunk-N2WTMF3X.js";function Pe(t){return["x","e","east","long","longitude"].includes(t.toLowerCase())}function ke(t){return["y","n","west","lat","latitude"].includes(t.toLowerCase())}function Vt(t){let{axes:e}=t.domain,s=Object.keys(e),r=[],i=[],a=-1,o=-1,l=[];for(let x=0;x<s.length;x++){let F=s[x];Pe(F)?a=x:ke(F)&&(o=x);let I=e[F],b=[];if("values"in I){I.values.forEach(w=>b.push(typeof w=="string"?new Date(w).getTime():w));let S=b[1]-b[0];r.push([b[0]-.5*S,b[b.length-1]+.5*S]),i.push(S)}else{let{start:S,stop:w,num:C}=I,_=(w-S)/(C-1);r.push([S-.5*_,w+.5*_]),i.push(_);for(let k=0;k<C;k++)b.push(S+_*k)}l.push({name:F,values:b,extent:[b[0],b[b.length-1]]})}a>-1&&o===-1?o=a===0?1:0:o>-1&&a===-1?a=o===0?1:0:o===-1&&a===-1&&(a=0,o=1),l=l.filter((x,F)=>!(F===a||F===o));let{referencing:n}=t.domain,m=n.find(x=>x.coordinates.includes(s[a])).system.id,c=m?.slice(m.lastIndexOf("/")+1),f=c==null||c==="CRS84"?4326:Number(c),u=new P({wkid:f}),[p,g]=r[a],[y,h]=r[o],d=new L({xmin:p,xmax:g,ymin:y,ymax:h,spatialReference:u});return{width:Math.round(d.width/i[a]),height:Math.round(d.height/i[o]),extent:d,dimensions:l}}function Oe(t){let e=He();return e?t[e]??Object.values(t)[0]:Object.values(t)[0]}function Me(){return Math.round(255*Math.random())}function Wt(t){let e={},{parameters:s}=t;if(!s)return e;for(let[r,i]of Object.entries(s)){let{type:a,description:o,unit:l,categoryEncoding:n,observedProperty:m}=i;if(a==="Parameter"&&(e[r]={},o&&(e[r].description=Oe(o)),l&&(e[r].unit=l.label?Oe(l.label):null,e[r].symbol=l.symbol?.value),n)){let c=Object.entries(n).map((p,g)=>({OID:g,Value:Number(p[1]),ClassName:p[0].slice(p[0].lastIndexOf("/")+1),Count:1})),f=!1;m?.categories?.length&&(m.categories.forEach(p=>{if(!p.id)return;let g=p.id.slice(p.id.lastIndexOf("/")+1),y=c.find(d=>d.ClassName===g);if(!y)return;let h=p.label?Oe(p.label):null;if(y.Label=h,p.preferredColor){let d=Xe.fromHex(p.preferredColor);d&&(f=!0,y.Red=d.r,y.Green=d.g,y.Blue=d.b)}}),f&&c.forEach(p=>{p.Red==null&&(p.Red=Me(),p.Green=Me(),p.Blue=Me())}));let u={objectIdFieldName:"",fields:[{name:"OID",type:"esriFieldTypeOID",alias:"OID",domain:null},{name:"Value",type:"esriFieldTypeInteger",alias:"Value",domain:null},{name:"Count",type:"esriFieldTypeDouble",alias:"Count",domain:null},{name:"ClassName",type:"esriFieldTypeString",alias:"ClassName",domain:null,length:50},{name:"Label",type:"esriFieldTypeString",alias:"Label",domain:null,length:50}],features:c.map(p=>({attributes:p}))};f&&u.fields.push({name:"Red",type:"esriFieldTypeInteger",alias:"Red",domain:null},{name:"Green",type:"esriFieldTypeInteger",alias:"Green",domain:null},{name:"Blue",type:"esriFieldTypeInteger",alias:"Blue",domain:null}),e[r].attributeTable=u}}return e}function qt(t){let e=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(let r=0;r<t.length;r++){let i=t[r];i!=null&&(i<e&&(e=i),i>s&&(s=i))}return rt(e,s)}function $t(t,e,s){let r=t.map((n,m)=>({name:n,count:e[m]})).sort((n,m)=>n.name>m.name?-1:1),i=(a=1,n=>a*=n.count);var a;let o=[...r.slice(1),{name:"",count:1}].reverse().map(i).reverse(),l=0;for(let n=t.length-1;n>=0;n--)l+=o[r.findIndex(({name:m})=>m===t[n])]*(s%e[n]),s=Math.floor(s/e[n]);return l}function Jt(t){let{width:e,height:s,extent:r,dimensions:i}=Vt(t),{ranges:a}=t,o=Object.keys(a).sort((u,p)=>u<p?-1:1),l=[];for(let u=0;u<o.length;u++){let p=o[u];i?.length&&l.push({name:p,dimensions:i})}let n=Wt(t);l.forEach(u=>n[u.name]&&Object.assign(u,n[u.name]));let m=l.length?{variables:l}:void 0,c=[];for(let u=0;u<o.length;u++){let p=o[u],{values:g,dataType:y,axisNames:h,shape:d}=a[p],x=d.length>2?u*d.slice(0,-2).reduce((C,_)=>C*_):0,F=h.slice(0,-2),I=d.slice(0,-2),b=y==="float"?"f32":qt(g),S=e*s,w=g.length/S;for(let C=0;C<w;C++){let _=K.createEmptyBand(b,S),k=new Uint8Array(S).fill(255),O=!1,E=C*S;for(let M=0;M<S;M++){let J=g[E+M];J==null?(k[M]=0,O=!0):_[M]=J}if(u===0||i?.length){let M=new K({width:e,height:s,mask:O?k:null,pixels:[_],pixelType:b});M.updateStatistics(),i?.length?c[$t(F,I,C)+x]=M:c.push(M)}else{let M=c[C];M.pixels.push(_),O?M.mask&&(M.mask=K.combineBandMasks([M.mask,k])):M.mask=O?k:null}}}let f=Object.values(n).find(u=>u.attributeTable)?.attributeTable;return{extent:r,pixelBlocks:c,multidimensionalInfo:m,attributeTable:f,bandNames:m?void 0:o}}var te=class extends U{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.source=null}get url(){return""}fetchRawTile(t,e,s,r={}){if(!this._pixelBlockTiles){let{rasterInfo:a}=this,[o,l]=a.storageInfo.tileInfo.size,{sliceId:n}=r,{pixelBlocks:m}=this.source,c={pixelBlock:n==null?m[0]:m[n],useBilinear:a.dataType!=="thematic",tileSize:{width:o,height:l},level:t,row:e,col:s},f=this.rasterJobHandler?this.rasterJobHandler.clipTile(c,r):dt(c);return Promise.resolve(f)}let i=this._pixelBlockTiles.get(`${t}/${e}/${s}`);return Promise.resolve(i)}async _open(t){let e=this.source,{pixelBlocks:s,attributeTable:r,statistics:i,histograms:a,name:o,nativeExtent:l,transform:n}=e,m=s[0],{width:c,height:f,pixelType:u}=m,p=e.extent??new L({xmin:-.5,ymin:.5,xmax:c-.5,ymax:f-.5,spatialReference:new P({wkid:3857})}),g=e.isPseudoSpatialReference??!e.extent,y={x:p.width/c,y:p.height/f},h=A({},e.keyProperties);r&&(h.DataType="Thematic");let d=new W({width:c,height:f,pixelType:u,extent:p,nativeExtent:l,attributeTable:r,transform:n,pixelSize:y,spatialReference:p.spatialReference,bandCount:m.pixels.length,keyProperties:h,multidimensionalInfo:e.multidimensionalInfo,statistics:i,isPseudoSpatialReference:g,histograms:a});this.ioConfig.skipMapInfo&&this.updateImageSpaceRasterInfo(d),this.createRemoteDatasetStorageInfo(d,512,512),this._set("rasterInfo",d),this.updateTileInfo(),d.multidimensionalInfo?await this._buildMDimStats(e.pixelBlocks,d.multidimensionalInfo):await this._buildInMemoryRaster(m,{width:512,height:512},t),d.multidimensionalInfo||(this.source=null),this.datasetName=o}async _buildInMemoryRaster(t,e,s){let{rasterInfo:r}=this,i=r.storageInfo.maximumPyramidLevel??0,a=r.dataType!=="thematic",o=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:t,tileSize:e,maximumPyramidLevel:i,useBilinear:a},s):Promise.resolve(ht(t,e,i,a)),l=r.statistics!=null,n=r.histograms!=null,m=this.ioConfig.skipStatistics||l?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:t},s):Promise.resolve(gt(t)),c=await xe([o,m]);if(!c[0].value&&c[1].value)throw new T("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=c[0].value,l||(r.statistics=c[1].value?.statistics),n||(r.histograms=c[1].value?.histograms)}async _buildMDimStats(t,e,s){for(let r=0;r<e.variables.length;r++){let i=e.variables[r];if(i.statistics)continue;let a=i.dimensions.map(m=>new St({variableName:i.name,dimensionName:m.name,values:[m.values?.[0]??m.extent?.[0]],isSlice:!0})),o=Pt(a,e),l=o==null?null:t[o];if(l==null)continue;let n=this.rasterJobHandler?await this.rasterJobHandler.computeStatisticsHistograms({pixelBlock:l},s):Ie(l);i.statistics=n.statistics,i.histograms||(i.histograms=n.histograms)}}};v([R({type:String,json:{write:!0}})],te.prototype,"datasetFormat",void 0),v([R()],te.prototype,"source",void 0),v([R()],te.prototype,"url",null),te=v([D("esri.layers.support.rasterDatasets.InMemoryRaster")],te);var se=te;var fe=class extends U{constructor(){super(...arguments),this.datasetFormat="CovJSON"}fetchRawTile(t,e,s,r={}){return this._inMemoryRaster.fetchRawTile(t,e,s,r)}async _open(t){let{extent:e,pixelBlocks:s,multidimensionalInfo:r,attributeTable:i,bandNames:a}=await this._fetchData(t),{statistics:o,histograms:l}=Ie(s[0]),n=a?.map(u=>({BandName:u})),m={DataType:i?"Thematic":r?"Scientific":"Generic",BandProperties:n},c=new se({source:{extent:e,pixelBlocks:s,attributeTable:i?we.fromJSON(i):null,multidimensionalInfo:r,statistics:o,histograms:l,keyProperties:m,isPseudoSpatialReference:!1}});await c.open(),this._inMemoryRaster=c;let f=this.source?"":this.url.slice(this.url.lastIndexOf("/")+1);this._set("datasetName",f.slice(0,f.indexOf("."))),this._set("rasterInfo",c.rasterInfo)}async _fetchData(t){let e=this.source??(await this.request(this.url,{signal:t?.signal})).data,s="imagery-tile-layer:open-coverage-json";if(e.type?.toLowerCase()!=="coverage"||e.domain?.domainType?.toLowerCase()!=="grid")throw new T(s,"Only coverage with Grid domain type is supported");if(!e.ranges)throw new T(s,"Missing ranges in the grid coverage data");if(!e.domain.referencing?.length)throw new T(s,"Missing domain referencing in the grid coverage data");let r=Object.values(e.ranges);for(let i=0;i<r.length;i++){let{axisNames:a,shape:o,type:l,values:n}=r[i];if(!(l.toLowerCase()==="ndarray"&&n?.length&&a?.length&&o?.length))throw new T(s,"Only ranges with valid NdArray, axisNames, shape, and inline values are supported");if(!(Pe(a[a.length-1])&&ke(a[a.length-2])))throw new T(s,"Only row-major ordered pixel values are supported. X axis must be the last axis.")}return Jt(e)}};v([R({type:String,json:{write:!0}})],fe.prototype,"datasetFormat",void 0),v([R({constructOnly:!0})],fe.prototype,"source",void 0),fe=v([D("esri.layers.support.rasterDatasets.CovJSONRaster")],fe);var zt=fe;function Ut(t,e){if(!t||!e)return null;let s=[];for(let r=0;r<t.length;r++)s.push(t[r]),s.push(e[r]);return s}function Yt(t){let e=H(t,"GeodataXform"),s=re(q(e,"SpatialReference/WKID")||G(e,"SpatialReference/WKT"));if(e.getAttribute("xsi:type")!=="typens:PolynomialXform")return{spatialReference:s,transform:null};let r=q(e,"PolynomialOrder")??1,i=ue(e,"CoeffX/Double"),a=ue(e,"CoeffY/Double"),o=ue(e,"InverseCoeffX/Double"),l=ue(e,"InverseCoeffY/Double"),n=Ut(i,a),m=Ut(o,l);return{spatialReference:s,transform:n&&m&&n.length&&m.length?new ee({spatialReference:s,polynomialOrder:r,forwardCoefficients:n,inverseCoefficients:m}):null}}function Xt(t){let e=q(t,"NoDataValue"),s=H(t,"Histograms/HistItem"),r=q(s,"HistMin"),i=q(s,"HistMax"),a=q(s,"BucketCount"),o=G(s,"HistCounts")?.split("|").map(u=>Number(u)),l,n,m,c;Ce(t,"Metadata/MDI").forEach(u=>{let p=Number(u.textContent??u.nodeValue);switch(u.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":l=p;break;case"STATISTICS_MAXIMUM":n=p;break;case"STATISTICS_MEAN":m=p;break;case"STATISTICS_STDDEV":c=p}});let f=q(t,"Metadata/SourceBandIndex");return{noDataValue:e,histogram:o?.length&&r!=null&&i!=null?{min:r,max:i,size:a||o.length,counts:o}:null,sourceBandIndex:f,statistics:l!=null&&n!=null?{min:l,max:n,avg:m,stddev:c}:null}}function re(t){if(!t)return null;let e=Number(t);if(!isNaN(e)&&e!==0)return new P({wkid:e});if(t=String(t).trim(),je(t))return new P({wkt2:t});let s=t.toUpperCase();if(s.startsWith("COMPD_CS")){if(!s.includes("VERTCS")||!s.includes("GEOGCS")&&!s.startsWith("PROJCS"))return null;let r=s.indexOf("VERTCS"),i=s.indexOf("PROJCS"),a=i>-1?i:s.indexOf("GEOGCS");if(a===-1)return null;let o=t.slice(a,t.lastIndexOf("]",r)+1).trim(),l=t.slice(r,t.lastIndexOf("]")).trim();e=Ne(o);let n=new P(e?{wkid:e}:{wkt:o}),m=Ne(l);return m&&(n.vcsWkid=m),n}return s.startsWith("GEOGCS")||s.startsWith("PROJCS")?(e=Ne(t),new P(e!==0?{wkid:e}:{wkt:t})):null}function Ne(t){let e=t.replaceAll("]","[").replaceAll('"',"").split("[").map(i=>i.trim()).filter(i=>i!==""),s=e[e.length-1].split(","),r=s[0]?.toLowerCase();if((r==="epsg"||r==="esri")&&t.endsWith('"]]')){let i=Number(s[1]);if(!isNaN(i)&&i!==0)return i}return 0}function ie(t){if(t?.documentElement.tagName?.toLowerCase()!=="pamdataset")return{};let e={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};t.documentElement.childNodes.forEach(r=>{if(r.nodeType===1){if(be(r,"SRS")){if(!e.spatialReference){let i=G(r);e.spatialReference=re(i)}}else if(be(r,"Metadata"))if(r.getAttribute("domain")==="xml:ESRI"){let{spatialReference:i,transform:a}=Yt(r);e.transform=a,e.spatialReference||(e.spatialReference=i)}else Ce(r,"MDI").forEach(i=>e.metadata[i.getAttribute("key")]=G(i));else if(be(r,"PAMRasterBand")){let i=Xt(r);i.sourceBandIndex!=null&&e.rasterBands[i.sourceBandIndex]==null?e.rasterBands[i.sourceBandIndex]=i:e.rasterBands.push(i)}}});let s=e.rasterBands;if(s.length){let r=!!s[0].statistics;e.statistics=r?s.map(a=>a.statistics).filter(ne):null;let i=!!s[0].histogram;e.histograms=i?s.map(a=>a.histogram).filter(ne):null}return e}var Se=class extends U{fetchRawTile(t,e,s,r={}){return this._inMemoryRaster.fetchRawTile(t,e,s,r)}async _open(t){let e=await this._fetchData(t),{spatialReference:s,statistics:r,histograms:i,transform:a}=await this._fetchAuxiliaryData(t),o=!s;o&&(s=new P({wkid:3857})),i?.length&&r==null&&(r=Z(i));let{width:l,height:n}=e,m=new L({xmin:-.5,ymin:.5-n,xmax:l-.5,ymax:.5,spatialReference:s}),c=a?a.forwardTransform(m):m,f=!0;if(a){let p=a.forwardCoefficients;f=p&&p[1]===0&&p[2]===0,f&&(a=null,m=c)}let u=new se({source:{extent:c,nativeExtent:m,transform:a,pixelBlocks:[e],statistics:r,histograms:i,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:o},ioConfig:{sampling:"closest",skipStatistics:!0}});this.ioConfig.skipMapInfo&&(u.ioConfig.skipMapInfo=!0),await u.open(),u.source=null,this._set("rasterInfo",u.rasterInfo),this._inMemoryRaster=u}async _fetchData(t){let{data:e}=await this.request(this.url,{responseType:"array-buffer",signal:t?.signal}),s=ut(e).toUpperCase();if(s!=="JPG"&&s!=="PNG"&&s!=="GIF"&&s!=="BMP")throw new T("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",s);let r=s.toLowerCase(),i=r==="gif"||r==="bmp"||!Ae("ios"),a=await this.decodePixelBlock(e,{format:r,useCanvas:i,hasNoZlibMask:!0});if(a==null)throw new T("image-aux-raster:open","the data cannot be decoded");return a}async _fetchAuxiliaryData(t){let e=t?.signal,{skipExtensions:s=[],skipMapInfo:r}=this.ioConfig,i=r||s.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:e}),a=this.datasetFormat,o=a==="JPG"?"jgw":a==="PNG"?"pgw":a==="BMP"?"bpw":null,l=o&&s.includes(o)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+o,{responseType:"text",signal:e}),n=await xe([i,l]);if(e?.aborted)throw De();let m=ie(n[0].value?.data);if(!m.transform){let c=n[1].value?n[1].value.data.split(`
`).slice(0,6).map(f=>Number(f)):null;m.transform=c?.length===6?new ee({forwardCoefficients:[c[4],c[5],c[0],-c[1],c[2],-c[3]]}):null}return m}};v([R({type:String,json:{write:!0}})],Se.prototype,"datasetFormat",void 0),Se=v([D("esri.layers.support.rasterDatasets.ImageAuxRaster")],Se);var he=Se;var de=class extends U{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async fetchRawTile(t,e,s,r={}){let{storageInfo:i,extent:a}=this.rasterInfo,{transposeInfo:o}=i,l=o!=null&&!!r.transposedVariableName;if(this._slices&&!l&&r.sliceId==null)return null;let n=l?0:i.maximumPyramidLevel-t+this._levelOffset,m=`${this.url}/tile/${n}/${e}/${s}`,c=this._slices?l?{variable:r.transposedVariableName}:{sliceId:r.sliceId||0}:null,{data:f}=await this.request(m,{query:c,responseType:"array-buffer",signal:r.signal});if(!f)return null;let u=l?o.tileSize:i.tileInfo.size,p=await this.decodePixelBlock(f,{width:u[0],height:u[1],planes:null,pixelType:null,isPoint:this.tileType==="Elevation",returnInterleaved:l,noDataValue:this.rasterInfo.noDataValue});if(p==null)return null;let g=i.blockBoundary[t];if(i.compression!=="jpg"||s>g.minCol&&s<g.maxCol&&e>g.minRow&&e<g.maxRow)return p;let{origin:y,blockWidth:h,blockHeight:d}=i,{x,y:F}=this.getPyramidPixelSize(t),I=Math.round((a.xmin-y.x)/x)%h,b=Math.round((a.xmax-y.x)/x)%h||h,S=Math.round((y.y-a.ymax)/F)%d,w=Math.round((y.y-a.ymin)/F)%d||d,C=s===g.minCol?I:0,_=e===g.minRow?S:0,k=s===g.maxCol?b:h,O=e===g.maxRow?w:d;return ft(p,{x:C,y:_},{width:k-C,height:O-_}),p}getSliceIndex(t){if(!this._slices||t==null||t.length===0)return null;let e=t;for(let s=0;s<this._slices.length;s++){let r=this._slices[s].multidimensionalDefinition;if(r.length===e.length&&!r.some(i=>{let a=e.find(o=>i.variableName===o.variableName&&o.dimensionName===i.dimensionName);return a?(Array.isArray(i.values[0])?`${i.values[0][0]}-${i.values[0][1]}`:i.values[0])!==(Array.isArray(a.values[0])?`${a.values[0][0]}-${a.values[0][1]}`:a.values[0]):!0}))return s}return null}async fetchVariableStatisticsHistograms(t,e){let s=this.request(this.url+"/statistics",{query:{variable:t,f:"json"},signal:e}).then(a=>a.data?.statistics),r=this.request(this.url+"/histograms",{query:{variable:t,f:"json"},signal:e}).then(a=>a.data?.histograms),i=await Promise.all([s,r]);return i[0]&&i[0].forEach(a=>{a.avg=a.mean,a.stddev=a.standardDeviation}),i[1]?.[0]?.counts?.length||(i[1]=null),{statistics:i[0]||null,histograms:i[1]||null}}async computeBestPyramidLevelForLocation(t,e={}){if(!this._tilemapCache)return 0;let s=this.identifyPixelLocation(t,0,e.datumTransformation);if(s===null)return null;let r=0,{maximumPyramidLevel:i}=this.rasterInfo.storageInfo,a=i-r+this._levelOffset,o=s.srcLocation;for(;a>=0;){try{if(await this._tilemapCache.fetchAvailability(a,s.row,s.col,e)==="available")break}catch{}if(a--,r++,s=this.identifyPixelLocation(o,r,e.datumTransformation),s===null)return null}return a===-1||s==null?null:r}async _open(t){let e=t?.signal,s=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:e});s.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));let r=s.data;if(this.sourceJSON=r,!r)throw new T("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!r.tileInfo)throw new T("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();let i=["jpg","jpeg","png","png8","png24","png32","mixed"];this.tileType=r.cacheType,this.tileType==null&&(i.includes(r.tileInfo.format.toLowerCase())?this.tileType="Map":r.tileInfo.format.toLowerCase()==="lerc"?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=r.name?.slice(r.name.indexOf("/")+1)??"";let a=await this._fetchRasterInfo({signal:e});if(a==null)throw new T("image-server-raster:open","cannot initialize image service");Nt(a,r);let o=this.tileType==="Map"?Kt(r.tileInfo,r):me.fromJSON(r.tileInfo);Be(o);let[l,n]=this._computeMinMaxLOD(a,o),{extent:m,pixelSize:c}=a,f=.5/a.width*c.x,u=Math.max(c.x,c.y),{lods:p}=o;(this.tileType!=="Map"&&r.maxScale!==0||Math.abs(c.x-c.y)>f||!p.some(w=>Math.abs(w.resolution-u)<f))&&(c.x=c.y=l.resolution,a.width=Math.ceil((m.xmax-m.xmin)/c.x-.1),a.height=Math.ceil((m.ymax-m.ymin)/c.y-.1));let g=l.level-n.level,[y,h]=o.size,d=[],x=[];p.forEach((w,C)=>{w.level>=n.level&&w.level<=l.level&&d.push({x:w.resolution,y:w.resolution}),C<p.length-1&&x.push(Math.round(10*w.resolution/p[C+1].resolution)/10)}),d.sort((w,C)=>w.x-C.x);let F=this.computeBlockBoundary(m,y,h,o.origin,d,g),I=d.length>1?d.slice(1):null,b;r.transposeInfo&&(b={tileSize:[r.transposeInfo.rows,r.transposeInfo.cols],packetSize:a.keyProperties?._yxs.PacketSize??0});let S=x.length<=1||x.length>=3&&x.slice(0,-1).every(w=>w===x[0])?x[0]??2:Math.round(10/(n.resolution/l.resolution)**(-1/g))/10;if(a.storageInfo=new Q({blockWidth:o.size[0],blockHeight:o.size[1],pyramidBlockWidth:o.size[0],pyramidBlockHeight:o.size[1],pyramidResolutions:I,pyramidScalingFactor:S,compression:o.format,origin:o.origin,firstPyramidLevel:1,maximumPyramidLevel:g,tileInfo:o,transposeInfo:b,blockBoundary:F}),Qt(a),this._set("rasterInfo",a),r.capabilities.toLowerCase().includes("tilemap")){let w={tileInfo:a.storageInfo.tileInfo,parsedUrl:Ue(this.url),url:this.url,tileServers:[]};this._tilemapCache=new Dt({layer:w})}}async _fetchRasterInfo(t){let e=this.sourceJSON;if(this.tileType==="Map"){let o=e.fullExtent||e.extent,l=Math.ceil((o.xmax-o.xmin)/e.pixelSizeX-.1),n=Math.ceil((o.ymax-o.ymin)/e.pixelSizeY-.1),m=P.fromJSON(e.spatialReference||o.spatialReference),c=new j({x:e.pixelSizeX,y:e.pixelSizeY,spatialReference:m});return new W({width:l,height:n,bandCount:3,extent:L.fromJSON(o),spatialReference:m,pixelSize:c,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}let{signal:s}=t,r=kt(this.url,this.sourceJSON,{signal:s,query:this.ioConfig.customFetchParameters}),i=e.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:s}).then(o=>o.data?.slices).catch(()=>null):null,a=await Promise.all([r,i]);return this._slices=a[1],a[0]}_fixScaleInServiceInfo(){let{sourceJSON:t}=this;t.minScale&&t.minScale<0&&(t.minScale=0),t.maxScale&&t.maxScale<0&&(t.maxScale=0)}_computeMinMaxLOD(t,e){let{pixelSize:s}=t,r=.5/t.width*s.x,{lods:i}=e,a=e.lodAt(Math.max.apply(null,i.map(u=>u.level))),o=e.lodAt(Math.min.apply(null,i.map(u=>u.level))),{tileType:l}=this;if(l==="Map")return this._levelOffset=i[0].level,[a,o];if(l==="Raster")return[i.find(u=>u.resolution===s.x)??a,o];let{minScale:n,maxScale:m}=this.sourceJSON,c=a;m>0&&(c=i.find(u=>Math.abs(u.scale-m)<r),c||(c=i.filter(u=>u.scale>m).sort((u,p)=>u.scale>p.scale?1:-1)[0]??a));let f=o;return n>0&&(f=i.find(u=>Math.abs(u.scale-n)<r)??o,this._levelOffset=f.level-o.level),[c,f]}};function Kt(t,e){if(!t)return null;let{minScale:s,maxScale:r,minLOD:i,maxLOD:a}=e;if(i!=null&&a!=null)return me.fromJSON(z(A({},t),{lods:t.lods.filter(({level:o})=>o!=null&&o>=i&&o<=a)}));if(s!==0&&r!==0){let o=m=>Math.round(1e4*m)/1e4,l=s?o(s):1/0,n=r?o(r):-1/0;return me.fromJSON(z(A({},t),{lods:t.lods.filter(m=>{let c=o(m.scale);return c<=l&&c>=n})}))}return me.fromJSON(t)}function Qt(t){let{extent:e,spatialReference:s}=t;e.xmin>-1&&e.xmax>181&&s?.wkid&&s.isGeographic&&(t.nativeExtent=t.extent,t.transform=new wt,t.extent=t.transform.forwardTransform(e))}v([R({type:String,json:{write:!0}})],de.prototype,"datasetFormat",void 0),v([R()],de.prototype,"tileType",void 0),de=v([D("esri.layers.support.rasterDatasets.ImageServerRaster")],de);var Ht=de;var V=new Map;V.set("Int8","s8"),V.set("UInt8","u8"),V.set("Int16","s16"),V.set("UInt16","u16"),V.set("Int32","s32"),V.set("UInt32","u32"),V.set("Float32","f32"),V.set("Float64","f32"),V.set("Double64","f32");var $=new Map;$.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),$.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),$.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),$.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});var ae=class extends U{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async fetchRawTile(t,e,s,r={}){let{blockWidth:i,blockHeight:a,blockBoundary:o}=this.rasterInfo.storageInfo,l=o[t];if(!l||l.maxRow<e||l.maxCol<s||l.minRow>e||l.minCol>s)return null;let{bandCount:n,pixelType:m}=this.rasterInfo,{ranges:c,actualTileWidth:f,actualTileHeight:u}=this._getTileLocation(t,e,s);if(!c||c.length===0)return null;if(c[0].from===0&&c[0].to===0){let O=new Uint8Array(i*a);return new K({width:i,height:a,pixels:void 0,mask:O,validPixelCount:0})}let{bandIds:p}=this.ioConfig,g=this._getBandSegmentCount(),y=[],h=0;for(h=0;h<g;h++)p&&!p.includes(h)||y.push(this.request(this._files.data,{range:{from:c[h].from,to:c[h].to},responseType:"array-buffer",signal:r.signal}));let d=await Promise.all(y),x=d.map(O=>O.data.byteLength).reduce((O,E)=>O+E),F=new Uint8Array(x),I=[],b=0;for(h=0;h<g;h++)I.push(b),F.set(new Uint8Array(d[h].data),b),b+=d[h].data.byteLength;let S=$.get(this.rasterInfo.storageInfo.compression).decoderFormat,w=await this.decodePixelBlock(F.buffer,{width:i,height:a,format:S,planes:p?.length||n,offsets:I,pixelType:m});if(w==null)return null;let{noDataValue:C}=this.rasterInfo;if(C!=null&&S!=="lerc"&&!w.mask&&(C=C[0],C!=null)){let O=w.width*w.height,E=new Uint8Array(O);if(Math.abs(C)>1e24)for(h=0;h<O;h++)Math.abs((w.pixels[0][h]-C)/C)>1e-6&&(E[h]=1);else for(h=0;h<O;h++)w.pixels[0][h]!==C&&(E[h]=1);w.mask=E}let _=0,k=0;if(f!==i||u!==a){let O=w.mask;if(O)for(h=0;h<a;h++)if(k=h*i,h<u)for(_=f;_<i;_++)O[k+_]=0;else for(_=0;_<i;_++)O[k+_]=0;else for(O=new Uint8Array(i*a),w.mask=O,h=0;h<u;h++)for(k=h*i,_=0;_<f;_++)O[k+_]=1}return w}async _open(t){this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);let e=t?t.signal:null,s=await this.request(this.url,{responseType:"xml",signal:e}),{rasterInfo:r,files:i}=this._parseHeader(s.data),{skipMapInfo:a,skipExtensions:o=[]}=this.ioConfig;if(!o.includes("aux.xml")&&!a){let d=await this._fetchAuxiliaryData(t);d!=null&&(r.statistics=d.statistics??r.statistics,r.histograms=d.histograms,d.histograms&&r.statistics==null&&(r.statistics=Z(d.histograms)))}a&&this.updateImageSpaceRasterInfo(r),this._set("rasterInfo",r),this._files=i;let l=await this.request(i.index,{responseType:"array-buffer",signal:e});this._storageIndex=Zt(l.data);let{blockWidth:n,blockHeight:m}=this.rasterInfo.storageInfo,c=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:f,height:u}=this.rasterInfo,p=[],g=this._getBandSegmentCount(),y=0,h=-1;for(;y<this._storageIndex.length;){h++;let d=Math.ceil(f/n/c**h)-1,x=Math.ceil(u/m/c**h)-1;y+=(d+1)*(x+1)*g*4,p.push({maxRow:x,maxCol:d,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=p,h>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=h),this.updateTileInfo()}_getBandSegmentCount(){return $.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(t,e,s){let{blockWidth:r,blockHeight:i,pyramidScalingFactor:a}=this.rasterInfo.storageInfo,{width:o,height:l}=this.rasterInfo,n=this._getBandSegmentCount(),m,c,f,u=0,p=0;for(f=0;f<t;f++)p=a**f,m=Math.ceil(o/r/p),c=Math.ceil(l/i/p),u+=m*c;p=a**t,m=Math.ceil(o/r/p),c=Math.ceil(l/i/p),u+=e*m+s,u*=4*n;let g=this._storageIndex.subarray(u,u+4*n),y=0,h=0,d=[];for(let x=0;x<n;x++)y=g[4*x]*2**32+g[4*x+1],h=y+g[4*x+2]*2**32+g[4*x+3],d.push({from:y,to:h});return{ranges:d,actualTileWidth:s<m-1?r:Math.ceil(o/p)-r*(m-1),actualTileHeight:e<c-1?i:Math.ceil(l/p)-i*(c-1)}}_parseHeader(t){let e=H(t,"MRF_META/Raster");if(!e)throw new T("mrf:open","not a valid MRF format");let s=H(e,"Size"),r=parseInt(s.getAttribute("x"),10),i=parseInt(s.getAttribute("y"),10),a=parseInt(s.getAttribute("c"),10),o=(G(e,"Compression")||"none").toLowerCase();if(!$.has(o))throw new T("mrf:open","currently does not support compression "+o);let l=G(e,"DataType")||"UInt8",n=V.get(l);if(n==null)throw new T("mrf:open","currently does not support pixel type "+l);let m=H(e,"PageSize"),c=parseInt(m.getAttribute("x"),10),f=parseInt(m.getAttribute("y"),10),u=H(e,"DataValues"),p,g;if(u&&(g=u.getAttribute("NoData"),g!=null&&(p=g.trim().split(" ").map(O=>parseFloat(O)))),H(t,"MRF_META/CachedSource"))throw new T("mrf:open","currently does not support MRF referencing other data files");let y=H(t,"MRF_META/GeoTags"),h=H(y,"BoundingBox"),d,x=!1;if(h!=null){let O=parseFloat(h.getAttribute("minx")),E=parseFloat(h.getAttribute("miny")),M=parseFloat(h.getAttribute("maxx")),J=parseFloat(h.getAttribute("maxy")),Y=G(y,"Projection")||"",ye=P.WGS84;if(Y!=="LOCAL_CS[]")if(Y.toLowerCase().startsWith("epsg:")){let Te=Number(Y.slice(5));isNaN(Te)||Te===0||(ye=new P({wkid:Te}))}else ye=re(Y)??P.WGS84;else x=!0,ye=new P({wkid:3857});d=new L(O,E,M,J),d.spatialReference=ye}else x=!0,d=new L({xmin:-.5,ymin:.5-i,xmax:r-.5,ymax:.5,spatialReference:new P({wkid:3857})});let F=H(t,"MRF_META/Rsets"),I=parseInt(F?.getAttribute("scale")||"2",10),b=d.spatialReference,S=new Q({origin:new j({x:d.xmin,y:d.ymax,spatialReference:b}),blockWidth:c,blockHeight:f,pyramidBlockWidth:c,pyramidBlockHeight:f,compression:o,pyramidScalingFactor:I}),w=new j({x:d.width/r,y:d.height/i,spatialReference:b}),C=new W({width:r,height:i,extent:d,isPseudoSpatialReference:x,spatialReference:b,bandCount:a,pixelType:n,pixelSize:w,noDataValue:p,storageInfo:S}),_=G(t,"datafile"),k=G(t,"IndexFile");return{rasterInfo:C,files:{mrf:this.url,index:k||this.url.replace(".mrf",".idx"),data:_||this.url.replace(".mrf",$.get(o).blobExtension)}}}async _fetchAuxiliaryData(t){try{let{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t?.signal});return ie(e)}catch{return null}}};function Zt(t){if(t.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let e,s,r,i,a,o;if(it){for(s=new Uint8Array(t),i=new ArrayBuffer(t.byteLength),r=new Uint8Array(i),a=0;a<t.byteLength/4;a++)for(o=0;o<4;o++)r[4*a+o]=s[4*a+3-o];e=new Uint32Array(i)}else e=new Uint32Array(t);return e}v([R()],ae.prototype,"_files",void 0),v([R()],ae.prototype,"_storageIndex",void 0),v([R({type:String,json:{write:!0}})],ae.prototype,"datasetFormat",void 0),ae=v([D("esri.layers.support.rasterDatasets.MRFRaster")],ae);var Gt=ae;function es(t){let e=t.fields,s=t.records,r=e.some(m=>m.name.toLowerCase()==="oid")?"OBJECTID":"OID",i=[{name:r,type:"esriFieldTypeOID",alias:"OID"}].concat(e.map(m=>({name:m.name,type:"esriFieldType"+m.typeName,alias:m.name}))),a=i.map(m=>m.name),o=[],l=0,n=0;return s.forEach(m=>{let c={};for(c[r]=l++,n=1;n<a.length;n++)c[a[n]]=m[n-1];o.push({attributes:c})}),{displayFieldName:"",fields:i,features:o}}var ve=class{static get supportedVersions(){return[5]}static parse(e){let s=new DataView(e),r=3&s.getUint8(0);if(r!==3)return{header:{version:r},recordSet:null};let i=s.getUint32(4,!0),a=s.getUint16(8,!0),o=s.getUint16(10,!0),l={version:r,recordCount:i,headerByteCount:a,recordByteCount:o},n=32,m=[],c=[],f;if(r===3){for(;s.getUint8(n)!==13;)f=String.fromCharCode(s.getUint8(n+11)).trim(),m.push({name:_e(new Uint8Array(e,n,11)),type:f,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(f)],length:s.getUint8(n+16)}),n+=32;if(n+=1,m.length>0)for(;c.length<i&&e.byteLength-n>o;){let u=[];s.getUint8(n)===32?(n+=1,m.forEach(p=>{if(p.type==="C")u.push(_e(new Uint8Array(e,n,p.length)).trim());else if(p.type==="N")u.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(e,n,p.length)).trim(),10));else if(p.type==="F")u.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(e,n,p.length)).trim()));else if(p.type==="D"){let g=String.fromCharCode.apply(null,new Uint8Array(e,n,p.length)).trim();u.push(new Date(parseInt(g.slice(0,4),10),parseInt(g.slice(4,6),10)-1,parseInt(g.slice(6,8),10)))}n+=p.length}),c.push(u)):n+=o}}return{header:l,fields:m,records:c,recordSet:es({fields:m,records:c})}}};var Ee=(t,e)=>t.get(e)?.values,ge=(t,e)=>t.get(e)?.values?.[0],X=class extends U{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async fetchRawTile(t,e,s,r={}){if(!this._headerInfo?.isSupported||this.isBlockOutside(t,e,s))return null;let i=await this._fetchRawTiffTile(t,e,s,!1,r);if(i!=null&&this._headerInfo.hasMaskBand){let a=await this._fetchRawTiffTile(t,e,s,!0,r);a!=null&&a.pixels[0]instanceof Uint8Array&&(i.mask=a.pixels[0])}return i}async _open(t){let e=t?t.signal:null,{data:s}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:e});if(!s)throw new T("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));let{littleEndian:r,firstIFDPos:i,isBigTiff:a}=ct(s),o=[];await this._readIFDs(o,s,r,i,0,a?8:4,e);let{imageInfo:l,rasterInfo:n}=ts(o),m=lt(o),c=mt(o);if(this._headerInfo=A({littleEndian:r,isBigTiff:a,ifds:o,pyramidIFDs:m,maskIFDs:c},l),this._set("rasterInfo",n),!l.isSupported)throw new T("tiffraster:open","this tiff is not supported: "+l.message);if(!l.tileWidth)throw new T("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");n.isPseudoSpatialReference&&le.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");let f=o[0].get("PREDICTOR")?.values?.[0];if(o[0].get("SAMPLEFORMAT")?.values?.[0]===3&&f===2)throw new T("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");let{skipMapInfo:p,skipExtensions:g=[]}=this.ioConfig;if(!g.includes("aux.xml")&&!p){let y=await this._fetchAuxiliaryMetaData(t);y!=null&&ss(y,n)}g.includes("vat.dbf")||n.bandCount!==1||n.pixelType!=="u8"||p||(n.attributeTable=await this._fetchAuxiliaryTable(t),n.attributeTable!=null&&(n.keyProperties.DataType="thematic")),p&&this.updateImageSpaceRasterInfo(n),this.updateTileInfo()}async _readIFDs(t,e,s,r,i,a=4,o){if(!r)return null;(r>=e.byteLength||r<0)&&(e=(await this.request(this.url,{range:{from:r+i,to:r+i+this._bufferSize},responseType:"array-buffer",signal:o})).data,i=r+i,r=0);let l=await this._readIFD(e,s,r,i,pe.tiffTags,a,o);if(t.push(l.ifd),!l.nextIFD)return null;await this._readIFDs(t,e,s,l.nextIFD-i,i,a,o)}async _readIFD(t,e,s,r,i=pe.tiffTags,a=4,o){if(!t)return null;let l=pt(t,e,s,r,i,a);if(l.success){let n=[];if(l.ifd?.forEach(m=>{m.values||n.push(m)}),n.length>0){let m=n.map(f=>f.offlineOffsetSize).filter(ne),c=Math.min.apply(null,m.map(f=>f[0]));if(Math.min.apply(null,m.map(f=>f[0]+f[1]))-c<=this._bufferSize){let{data:f}=await this.request(this.url,{range:{from:c,to:c+this._bufferSize},responseType:"array-buffer",signal:o});t=f,r=c,n.forEach(u=>at(t,e,u,r))}}if(l.ifd?.has("GEOKEYDIRECTORY")){let m=l.ifd.get("GEOKEYDIRECTORY"),c=m?.values;if(c&&c.length>4){let f=c[0]+"."+c[1]+"."+c[2],u=await this._readIFD(t,e,m.valueOffset+6-r,r,pe.geoKeys,2,o);m.data=u.ifd,m.data&&m.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[f]})}}return l}if(l.requiredBufferSize&&l.requiredBufferSize!==t.byteLength)return(t=(await this.request(this.url,{range:{from:r,to:r+l.requiredBufferSize+4},responseType:"array-buffer",signal:o})).data).byteLength<l.requiredBufferSize?null:this._readIFD(t,e,0,r,pe.tiffTags,4,o)}async _fetchRawTiffTile(t,e,s,r,i={}){let a=this._getTileLocation(t,e,s,r);if(!a)return null;let{ranges:o,actualTileWidth:l,actualTileHeight:n,ifd:m}=a,c=o.map(S=>this.request(this.url,{range:S,responseType:"array-buffer",signal:i.signal})),f=await Promise.all(c),u=f.map(S=>S.data.byteLength).reduce((S,w)=>S+w),p=f.length===1?f[0].data:new ArrayBuffer(u),g=[0],y=[0];if(f.length>1){let S=new Uint8Array(p);for(let w=0,C=0;w<f.length;w++){let _=f[w].data;S.set(new Uint8Array(_),C),g[w]=C,C+=_.byteLength,y[w]=_.byteLength}}let{blockWidth:h,blockHeight:d}=this.getBlockWidthHeight(t),x=await this.decodePixelBlock(p,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:m,offsets:g,sizes:y},width:h,height:d,planes:null,pixelType:null});if(x==null)return null;let F,I,b;if(l!==h||n!==d){let S=x.mask;if(S)for(F=0;F<d;F++)if(b=F*h,F<n)for(I=l;I<h;I++)S[b+I]=0;else for(I=0;I<h;I++)S[b+I]=0;else for(S=new Uint8Array(h*d),x.mask=S,F=0;F<n;F++)for(b=F*h,I=0;I<l;I++)S[b+I]=1}return x}_getTileLocation(t,e,s,r=!1){let{firstPyramidLevel:i,blockBoundary:a}=this.rasterInfo.storageInfo,o=t===0?0:t-(i-1),{_headerInfo:l}=this;if(!l)return null;let n=r?l.maskIFDs[o]:o===0?l?.ifds[0]:l?.pyramidIFDs[o-1];if(!n)return null;let m=nt(n,l),c=Ee(n,"TILEOFFSETS");if(c===void 0)return null;let f=Ee(n,"TILEBYTECOUNTS"),{minRow:u,minCol:p,maxRow:g,maxCol:y}=a[o];if(e>g||s>y||e<u||s<p)return null;let h=ge(n,"IMAGEWIDTH"),d=ge(n,"IMAGELENGTH"),x=ge(n,"TILEWIDTH"),F=ge(n,"TILELENGTH"),I=[];if(m){let{bandCount:b}=this.rasterInfo;for(let S=0;S<b;S++){let w=S*(g+1)*(y+1)+e*(y+1)+s;I[S]={from:c[w],to:c[w]+f[w]-1}}}else{let b=e*(y+1)+s;I.push({from:c[b],to:c[b]+f[b]-1})}for(let b=0;b<I.length;b++)if(I[b].from==null||!I[b].to||I[b].to<0)return null;return{ranges:I,ifd:n,actualTileWidth:s===y&&h%x||x,actualTileHeight:e===g&&d%F||F}}async _fetchAuxiliaryMetaData(t){try{let{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t?.signal});return ie(e)}catch{return null}}async _fetchAuxiliaryTable(t){try{let{data:e}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:t?.signal}),s=ve.parse(e);return s?.recordSet?we.fromJSON(s.recordSet):null}catch{return null}}};function ts(t){let e=ot(t),{width:s,height:r,tileWidth:i,tileHeight:a,planes:o,pixelType:l,compression:n,firstPyramidLevel:m,maximumPyramidLevel:c,pyramidBlockWidth:f,pyramidBlockHeight:u,pyramidResolutions:p,tileBoundary:g,affine:y,metadata:h}=e,d=e.extent.spatialReference?.wkt||e.extent.spatialReference?.wkid,x=re(d),F=!!e.isPseudoGeographic;x==null&&(F=!0,x=new P({wkid:3857}));let I=new L(z(A({},e.extent),{spatialReference:x})),b=new j(I?{x:I.xmin,y:I.ymax,spatialReference:x}:{x:0,y:0}),S=new Q({blockWidth:i,blockHeight:a,pyramidBlockWidth:f,pyramidBlockHeight:u,compression:n,origin:b,firstPyramidLevel:m,maximumPyramidLevel:c,pyramidResolutions:p,blockBoundary:g}),w=new j({x:(I.xmax-I.xmin)/s,y:(I.ymax-I.ymin)/r,spatialReference:x}),C=h?{BandProperties:h.bandProperties,DataType:h.dataType}:{},_=null,k=ge(t[0],"PHOTOMETRICINTERPRETATION"),O=Ee(t[0],"COLORMAP");if(k<=3&&O?.length>3&&O.length%3==0){_=[];let M=O.length/3;for(let J=0;J<M;J++)_.push([J,O[J]>>>8,O[J+M]>>>8,O[J+2*M]>>>8])}let E=new W({width:s,height:r,bandCount:o,pixelType:l,pixelSize:w,storageInfo:S,spatialReference:x,isPseudoSpatialReference:F,keyProperties:C,extent:I,colormap:_,statistics:h?h.statistics:null});if(y?.length&&(E.nativeExtent=new L({xmin:-.5,ymin:.5-r,xmax:s-.5,ymax:.5,spatialReference:x}),E.transform=new ee({polynomialOrder:1,forwardCoefficients:[y[2]+y[0]/2,y[5]-y[3]/2,y[0],y[3],-y[1],-y[4]]}),E.extent=E.transform.forwardTransform(E.nativeExtent),E.pixelSize=new j({x:(I.xmax-I.xmin)/s,y:(I.ymax-I.ymin)/r,spatialReference:x}),S.origin.x=-.5,S.origin.y=.5),p){let{x:M,y:J}=E.pixelSize;p.forEach(Y=>{Y.x*=M,Y.y*=J})}return{imageInfo:e,rasterInfo:E}}function ss(t,e){if(e.statistics=t.statistics??e.statistics,e.histograms=t.histograms,t.histograms&&e.statistics==null&&(e.statistics=Z(t.histograms)),t.transform&&e.transform==null){e.transform=t.transform,e.nativeExtent=e.extent;let s=e.transform.forwardTransform(e.nativeExtent);e.pixelSize=new j({x:(s.xmax-s.xmin)/e.width,y:(s.ymax-s.ymin)/e.height,spatialReference:e.spatialReference}),e.extent=s}e.isPseudoSpatialReference&&t.spatialReference&&(e.spatialReference=t.spatialReference,e.extent.spatialReference=e.nativeExtent.spatialReference=e.storageInfo.origin.spatialReference=e.spatialReference)}v([R()],X.prototype,"_files",void 0),v([R()],X.prototype,"_headerInfo",void 0),v([R()],X.prototype,"_bufferSize",void 0),v([R({type:String,json:{write:!0}})],X.prototype,"datasetFormat",void 0),X=v([D("esri.layers.support.rasterDatasets.TIFFRaster")],X);var jt=X;var B=new Map;B.set("MRF",{desc:"Meta Raster Format",constructor:Gt}),B.set("TIFF",{desc:"GeoTIFF",constructor:jt}),B.set("RasterTileServer",{desc:"Raster Tile Server",constructor:Ht}),B.set("JPG",{desc:"JPG Raster Format",constructor:he}),B.set("PNG",{desc:"PNG Raster Format",constructor:he}),B.set("GIF",{desc:"GIF Raster Format",constructor:he}),B.set("BMP",{desc:"BMP Raster Format",constructor:he}),B.set("CovJSON",{desc:"COVJSON Raster Format",constructor:zt}),B.set("MEMORY",{desc:"In Memory Raster Format",constructor:se});var oe=class{static get supportedFormats(){let e=new Set;return B.forEach((s,r)=>e.add(r)),e}static async open(e){let{url:s,ioConfig:r,source:i,sourceJSON:a}=e,o=e.datasetFormat??r?.datasetFormat;o==null&&(s.includes(".")?o=s.slice(s.lastIndexOf(".")+1).toUpperCase():i?.type?.toLowerCase()==="coverage"?o="CovJSON":i?.extent&&i.pixelblocks&&(o="MEMORY")),o==="OVR"||o==="TIF"?o="TIFF":o==="JPG"||o==="JPEG"||o==="JFIF"?o="JPG":o==="COVJSON"&&(o="CovJSON"),s.toLowerCase().includes("/imageserver")&&!s.toLowerCase().includes("/wcsserver")&&(o="RasterTileServer");let l={url:s,source:i,sourceJSON:a,datasetFormat:o,ioConfig:r??{bandIds:null,sampling:null}};if(Object.keys(l).forEach(f=>{l[f]==null&&delete l[f]}),o){if(!this.supportedFormats.has(o))throw new T("rasterfactory:open","not a supported format "+o);if(o==="CRF")throw new T("rasterfactory:open",`cannot open raster: ${s}`);let f=new(B.get(o)).constructor(l);return await f.open({signal:e.signal}),f}let n=Array.from(B.keys()).filter(f=>f!=="CovJSON"&&f!=="Memory"),m=0,c=()=>{if(o=n[m++],!o||o==="CRF")return null;let f=new(B.get(o)).constructor(l);return f.open({signal:e.signal}).then(()=>f).catch(()=>c())};return c()}static register(e,s,r){B.has(e.toUpperCase())||B.set(e.toUpperCase(),{desc:s,constructor:r})}};var N=class extends We($e(bt(et(Et(Ze(Bt(tt(Qe(qe(Ve(Ye.ClonableMixin(Lt)))))))))))){constructor(...t){super(...t),this._primaryRasters=[],this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this.source=void 0,this._debouncedSaveOperations=Je(async(e,s,r)=>{let{save:i,saveAs:a}=await import("./chunk-SQWWLHXG.js");switch(e){case ce.SAVE:return i(this,s);case ce.SAVE_AS:return a(this,r,s)}})}normalizeCtorArgs(t,e){return typeof t=="string"?A({url:t},e):t}load(t){let e=t!=null?t.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},t).catch(Le).then(()=>this._openRaster(e))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){let t=[Tt("Pixel Value"),Rt("Raw Pixel Value")],e=this.raster?.rasterInfo??this.serviceRasterInfo,s=e?.attributeTable;if(s){let a=Ct(s);t.push(...a)}let r=e?.dataType,i=e?.multidimensionalInfo;if((r==="vector-magdir"||r==="vector-uv")&&i!=null){let a=i.variables[0].unit?.trim(),o=_t(a),l=Ft();t.push(o,l)}if(i){let a=Ot(i);t.push(...a)}return t}createPopupTemplate(t){let{rasterFields:e}=this,s=t?.visibleFieldNames??new Set(e.map(({name:a})=>a).filter(a=>a!==vt.rawServicePixelValue)),r=st({fields:e,title:this.title},z(A({},t),{visibleFieldNames:s})),{rasterInfo:i}=this.raster;return r?.fieldInfos&&i&&Mt(r.fieldInfos,i),r}async generateRasterInfo(t,e){if(t=ze(Fe,t),await this.load(),!t||t.functionName?.toLowerCase()==="none")return this.serviceRasterInfo;try{let{rasterInfo:s}=await this._openFunctionRaster(t,e);return s}catch(s){throw s instanceof T?s:new T("imagery-tile-layer","the given raster function is not supported")}}async save(t){return this._debouncedSaveOperations(ce.SAVE,t)}async saveAs(t,e){return this._debouncedSaveOperations(ce.SAVE_AS,e,t)}write(t,e){let s=this._primaryRasters[0]??this.raster;if(this.loaded?s.datasetFormat==="RasterTileServer"&&(s.tileType==="Raster"||s.tileType==="Map"):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(t,e);if(e?.messages){let r=`${e.origin}/${e.layerContainerType||"operational-layers"}`;e.messages.push(new T("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${r}'`,{layer:this}))}return null}async _openRaster(t){let e=!1;if(this.raster)await this._openFromRaster(this.raster,t),e=this.raster.datasetFormat==="Function",!e&&this.rasterFunction&&(this._primaryRasters=[this.raster],await this._initializeWithFunctionRaster(this.rasterFunction));else{let{url:r,rasterFunction:i,source:a}=this;if(!r&&!a)throw new T("imagery-tile-layer:open","missing url or source parameter");a?await this._openFromSource(a,t):i?await this._openFromUrlWithRasterFunction(r,i,t):await this._openFromUrl(r,t)}let s=this.raster.rasterInfo;if(!s)throw new T("imagery-tile-layer:load","cannot load resources on "+this.url);if(this._set("serviceRasterInfo",e?s:this._primaryRasters[0].rasterInfo),this._set("spatialReference",s.spatialReference),this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,this.sourceJSON!=null){let r=this.raster.tileType==="Map"&&this.sourceJSON.minLOD!=null&&this.sourceJSON.maxLOD!=null?this.sourceJSON:z(A({},this.sourceJSON),{minScale:0,maxScale:0});this.read(r,{origin:"service"})}else this.read({tileInfo:this.serviceRasterInfo?.storageInfo.tileInfo.toJSON()},{origin:"service"});this.title||(this.title=this.raster.datasetName),this.raster.tileType==="Map"&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles(Ge(()=>this.customParameters,r=>{this.raster&&(this.raster.ioConfig.customFetchParameters=r)}))}async _openFromRaster(t,e){t.rasterInfo||await t.open({signal:e}),this._primaryRasters=t.datasetFormat==="Function"?t.primaryRasters.rasters:[t],this.url||(this.url=this._primaryRasters[0].url)}async _openFromUrlWithRasterFunction(t,e,s){let r=[t];e&&yt(e.toJSON(),r);let i=await Promise.all(r.map(o=>oe.open({url:o,sourceJSON:this.sourceJSON,ioConfig:z(A({sampling:"closest"},this.ioConfig),{customFetchParameters:this.customParameters}),signal:s}))),a=i.findIndex(o=>o==null);if(a>-1)throw new T("imagery-tile-layer:open",`cannot open raster: ${r[a]}`);return this._primaryRasters=i,this._initializeWithFunctionRaster(e)}async _openFromUrl(t,e){let s=await oe.open({url:t,sourceJSON:this.sourceJSON,ioConfig:z(A({sampling:"closest"},this.ioConfig),{customFetchParameters:this.customParameters}),signal:e});if(s==null)throw new T("imagery-tile-layer:open",`cannot open raster: ${t}`);this._primaryRasters=[s],this.raster=s}async _openFromSource(t,e){let s="the tiled imagery data source is not supported",r=t.type?.toLowerCase()==="coverage"?"CovJSON":t.extent&&t.pixelBlock?"MEMORY":null;if(!r)throw new T("imagery-tile-layer:open",s);r==="MEMORY"&&(t=z(A({},t),{pixelBlock:void 0,pixelBlocks:[t.pixelBlock]}));let i=await oe.open({url:"",source:t,datasetFormat:r,ioConfig:z(A({sampling:"closest"},this.ioConfig),{customFetchParameters:this.customParameters}),signal:e});if(i==null)throw new T("imagery-tile-layer:open",s);this._primaryRasters=[i],this.rasterFunction?await this._initializeWithFunctionRaster(this.rasterFunction):this.raster=i}async _openFunctionRaster(t,e){let s={raster:this._primaryRasters[0]};this._primaryRasters.length>1&&this._primaryRasters.forEach(a=>s[a.url]=a);let r=xt(t.functionDefinition?.toJSON()??t.toJSON(),s),i=new At({rasterFunction:r});return await i.open(e),i}async _initializeWithFunctionRaster(t,e){try{this.raster=await this._openFunctionRaster(t,e)}catch(s){s instanceof T&&le.getLogger(this).error("imagery-tile-layer:open",s.message),le.getLogger(this).warn("imagery-tile-layer:open","the raster function cannot be applied and is removed"),this._set("rasterFunction",null),this.raster=this._primaryRasters[0]}}};v([R({clonable:!1})],N.prototype,"_primaryRasters",void 0),v([R(It)],N.prototype,"legendEnabled",void 0),v([R({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],N.prototype,"isReference",void 0),v([R({type:["show","hide"]})],N.prototype,"listMode",void 0),v([R({json:{read:!0,write:!0}})],N.prototype,"blendMode",void 0),v([R({type:Fe,json:{name:"renderingRule",write:!0}})],N.prototype,"rasterFunction",void 0),v([R()],N.prototype,"sourceJSON",void 0),v([R({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],N.prototype,"version",void 0),v([R({readOnly:!0,json:{read:!1}})],N.prototype,"type",void 0),v([R({type:["ArcGISTiledImageServiceLayer"]})],N.prototype,"operationalLayerType",void 0),v([R({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(t,e)=>!e.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}},writer(t,e,s){e[s]=!t}}}})],N.prototype,"popupEnabled",void 0),v([R({type:Ke,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}}}}})],N.prototype,"popupTemplate",void 0),v([R({readOnly:!0})],N.prototype,"defaultPopupTemplate",null),v([R({readOnly:!0,type:[Re]})],N.prototype,"fields",void 0),v([R({readOnly:!0,type:[Re]})],N.prototype,"rasterFields",null),v([R({constructOnly:!0})],N.prototype,"source",void 0),N=v([D("esri.layers.ImageryTileLayer")],N);var ha=N;export{ha as default};
